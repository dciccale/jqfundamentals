<!doctype html>
<html lang="es-es">

<head>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1" >
	<meta charset="utf-8">
	<meta http-equiv="Content-language" content="es" />
	<meta name="description" content="Fundamentos de jQuery - Libro gratuito de jQuery en espa&ntilde;ol" />
	<meta property="og:title" content="Fundamentos de jQuery - Libro gratuito de jQuery en espa&ntilde;ol"/>
	<meta property="og:image" content="http://librojquery.com/css/jquery_logo.png"/>
	<title>Fundamentos de jQuery - Libro gratuito de jQuery en espa&ntilde;ol</title>
	<link rel="stylesheet" type="text/css" href="css/style.css" media="screen, projection">
	<link rel="stylesheet" type="text/css" href="css/stylePrint.css" media="print">
	<link rel="stylesheet" type="text/css" href="css/shCore.css">
	<link rel="stylesheet" type="text/css" href="css/shThemeRDark.css">
</head>

<body>
  
	<div title="Fundamentos de jQuery">
    
		<div id="titlepage">
		
			<h1 class="title maintitle">
				<a title="Fundamentos de jQuery" href="http://librojquery.com/">Fundamentos de jQuery</a>
			</h1>
			<div class="social">
				<iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Flibrojquery.com%2F&amp;layout=button_count&amp;show_faces=false&amp;width=115&amp;action=like&amp;font&amp;colorscheme=light&amp;height=21" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:115px; height:21px;" allowTransparency="true"></iframe>
				<a href="http://twitter.com/share" class="twitter-share-button" data-count="none" data-via="dzignus" data-lang="es">Tweet</a>
			</div>
			<div class="clear"></div>
          
			<h3>Textos originales por <a href="http://www.rebeccamurphey.com">Rebecca Murphey</a></h3>
          
			<div class="translators">
				<h3 class="translator">Traducido y adaptado a espa&ntilde;ol por <a href="http://dzign.us/">Leandro D'Onofrio</a>.</h3>
				<h3 class="corrections">Correcciones por <a href="http://ar.linkedin.com/in/gustavoaragon/">Gustavo Ra&uacute;l Arag&oacute;n</a>, <a href="http://www.linkedin.com/pub/pablo-andr%C3%A9s-maronna/10/713/373">Pablo Maronna</a>, <a href="http://es.linkedin.com/in/denisciccale">Denis Ciccale</a>  y <a href="https://github.com/dzignus/jqfundamentals/wiki/Otras-personas-que-tambi%C3%A9n-ayudaron-con-el-material">otras personas</a>.</h3>
			</div>
          
			<h3>Con contribuciones de James Padolsey, Paul Irish y otros. Para un completo historial de contribuciones visite el repositorio en GitHub.</h3>
			
			<h3><a href="https://github.com/dzignus/jqfundamentals" rel="_blank">Repositorio en espa&ntilde;ol</a> | <a href="http://github.com/rmurphey/jqfundamentals" rel="_blank">Repositorio original</a></h3>
          
			<h4>¿Tienes <a href="https://github.com/dzignus/jqfundamentals/wiki/Correcciones" rel="_blank">correcciones</a> o <a href="https://github.com/dzignus/jqfundamentals/wiki/Mejoras-del-material" rel="_blank">mejoras del material</a>?</h4>
          
			<p title="Aviso Legal">Bajo licencia <a href="http://creativecommons.org/licenses/by-sa/3.0/us/" rel="_blank">Creative Commons Attribution-Share Alike 3.0 United States</a>.</p>
			
			<p><strong>Última actualización del libro:</strong> Julio 2011 (<a href="https://github.com/dzignus/jqfundamentals/commits/master" rel="_blank">ver cambios</a>).</p>

		</div> <!-- end titlepage -->

		<h2>Contenidos</h2>
		<ul id="toc">
			<!-- JS-generated TOC goes here -->
		</ul>

		<h2>Listado de ejemplos</h2>
		<ul id="loe">
		<!-- JS-generated list of examples goes here -->
		</ul>
		
		        <div id="capitulo-1" title="Bienvenido" class="chapter">
		  <h2 class="title">Bienvenido</h2>
        <p>
          jQuery se est&aacute; convirtiendo r&aacute;pidamente en una herramienta que todo desarrollador de interfaces web deber&iacute;a de conocer. El prop&oacute;sito de este libro es proveer un resumen de la biblioteca, de tal forma que para cuando lo haya terminado de leer, ser&aacute; capaz de realizar tareas b&aacute;sicas utilizando jQuery y tendr&aacute; una s&oacute;lida base para continuar el aprendizaje. El libro fue dise&ntilde;ado para ser utilizado como material en un sal&oacute;n de clases, pero tambi&eacute;n puede ser &uacute;til para estudiarlo de forma individual.
        </p>
        <p>
          La modalidad de trabajo es la siguiente: En primer lugar se dedicar&aacute; tiempo a comprender un concepto para luego realizar un ejercicio relacionado. Algunos de los ejercicios pueden llegar a ser triviales, mientras que otros no tanto. El objetivo es aprender a resolver de manera f&aacute;cil lo que normalmente se resolver&iacute;a con jQuery. Las soluciones a todos los ejercicios est&aacute;n incluidas en el mismo material de aprendizaje.
        </p>
        <div title="Obtener el Material de Aprendizaje" class="section">
          <h2>Obtener el Material de Aprendizaje</h2>
          <p>
            El material de aprendizaje y el c&oacute;digo fuente de los ejemplos que se utilizan en el libro est&aacute;n hospedados en <a href="http://github.com/rmurphey/jqfundamentals">un repositorio de Github</a>. Desde all&iacute; es posible descargar un archivo .zip o .tar con el c&oacute;digo para utilizar en un servidor web. 
          </p>
		  <p>
		   Si usted suele utilizar <a href="http://git-scm.com/">Git</a>, es bienvenido de clonar o modificar el repositorio.
		  </p>
        </div>
        <div title="Software" class="section">
          <h2>Software</h2>
          <p>
            Para trabajar con los contenidos del libro, necesitar&aacute; las siguientes herramientas:
          </p>
          <ul>
            <li>
              <p>
                <a href="http://www.mozilla.com/es-AR/firefox/" rel="_blank">Navegador web Firefox</a>
              </p>
            </li>
            <li>
              <p>
                La <a href="https://addons.mozilla.org/es-ES/firefox/addon/firebug/" rel="_blank">extensi&oacute;n Firebug</a>, para Firefox
              </p>
            </li>
            <li>
              <p>
                Un editor de textos planos (como <a href="http://notepad-plus-plus.org/download/v5.9.2.html" rel="_blank">Notepad++</a> para Windows, <a href="http://www.icewalkers.com/Linux/Software/56260/gEdit.html" rel="_blank">gedit</a>/<a href="http://linux.softpedia.com/get/Text-Editing-Processing/Others/Kate-2317.shtml" rel="_blank">Kate</a> para Linux &oacute; <a href="http://textmate.en.softonic.com/mac" rel="_blank">TextMate</a> para Mac OS X)
              </p>
            </li>
            <li>
              <p>
                Para las secciones dedicadas a Ajax: Un servidor local (como <a href="http://www.wampserver.com/en/download.php" rel="_blank">WAMP</a> o <a href="http://www.mamp.info/en/index.html" rel="_blank">MAMP</a>) &oacute; un cliente FTP/SSH (como <a href="http://filezilla-project.org/" rel="_blank">FileZilla</a>) para acceder a un servidor remoto.
              </p>
            </li>
          </ul>
        </div>
        <div title="A&ntilde;adir JavaScript a una P&aacute;gina" class="section">
          <h2>A&ntilde;adir JavaScript a una P&aacute;gina</h2>
          <p>
            Existen dos formas de insertar c&oacute;digo JavaScript dentro de una p&aacute;gina: escribiendo c&oacute;digo en la misma (en ingles inline) &oacute; a trav&eacute;s de un archivo externo utilizando la etiqueta script. El orden en el cual se incluye el c&oacute;digo es importante: un c&oacute;digo que depende de otro debe ser incluido despu&eacute;s del que referencia (Ejemplo: Si la funci&oacute;n B depende de A, el orden debe ser A,B y no B,A).
          </p>
          <p>
            Para mejorar el rendimiento de la p&aacute;gina, el c&oacute;digo JavaScript debe ser incluido al final del HTML. Adem&aacute;s, cuando se trabaja en un ambiente de producci&oacute;n con m&uacute;ltiples archivos JavaScript, &eacute;stos deben ser combinados en un solo archivo.
          </p>
          <div class="example">
            <p class="title">
              <b>Ejemplo de c&oacute;digo JavaScript en l&iacute;nea</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
&lt;script&gt;
console.log('hello');
&lt;/script&gt;
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Ejemplo de inclusi&oacute;n de un archivo externo JavaScript</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
&lt;script src='/js/jquery.js'&gt;&lt;/script&gt;
</pre>
            </div>
          </div>
        </div>
        <div title="Depuraci&oacute;n del C&oacute;digo JavaScript" class="section">
          <h2>Depuraci&oacute;n del C&oacute;digo JavaScript</h2>
          <p>
            La utilizaci&oacute;n de una herramienta de depuraci&oacute;n es esencial para trabajar con JavaScript. Firefox provee un depurador a trav&eacute;s de la extensi&oacute;n Firebug; mientras que <a href="http://www.apple.com/es/safari/download/" rel="_blank">Safari</a> y <a href="http://www.google.es/chrome/" rel="_blank">Chrome</a> ya traen uno integrado.
          </p>
          <p>
            Cada depurador ofrece:
          </p>
          <ul>
            <li>
              <p>
                Un editor multi-linea para experimentar con JavaScript;
              </p>
            </li>
            <li>
              <p>
                Un inspector para revisar el c&oacute;digo generado en la p&aacute;gina;
              </p>
            </li>
            <li>
              <p>
                Un visualizador de red o recursos, para examinar las peticiones que se realizan.
              </p>
            </li>
          </ul>
          <p>
            Cuando usted este escribiendo c&oacute;digo JavaScript, podr&aacute; utilizar alguno de los siguientes m&eacute;todos para enviar mensajes a la consola del depurador:
          </p>
          <ul>
            <li>
              <code>console.log()</code> para enviar y registrar mensajes generales;
            </li>
            <li>
              <code>console.dir()</code> para registrar un objeto y visualizar sus propiedades;
            </li>
            <li>
              <code>console.warn()</code> para registrar mensajes de alerta;
            </li>
            <li>
              <code>console.error()</code> para registrar mensajes de error;
            </li>
          </ul>
          <p>
            Existen otros m&eacute;todos para utilizar desde la consola, pero estos pueden variar seg&uacute;n el navegador. La consola adem&aacute;s provee la posibilidad de establecer puntos de interrupci&oacute;n y observar expresiones en el c&oacute;digo con el fin de facilitar su depuraci&oacute;n.
          </p>
        </div>
        <div title="Ejercicios" class="section">
          <h2>Ejercicios</h2>
          <p>
            La mayor&iacute;a de los cap&iacute;tulos concluyen con uno o m&aacute;s ejercicios. En algunos, podr&aacute; trabajar directamente con Firebug; en otros deber&aacute; escribir c&oacute;digo JavaScript luego de incluir la biblioteca jQuery en el documento.
          </p>
          <p>
            A&uacute;n as&iacute;, para completar ciertos ejercicios, necesitar&aacute; consultar la documentaci&oacute;n oficial de jQuery. Aprender a encontrar respuestas, es una parte importante del proceso de aprendizaje.
          </p>
          <p>
            Estas son algunas sugerencias para hacer frente a los problemas:
          </p>
          <ul>
            <li>
              <p>
                En primer lugar, aseg&uacute;rese de entender bien el problema que est&aacute; tratando de resolver.
              </p>
            </li>
            <li>
              <p>
                Luego, averigüe a qu&eacute; elementos tendr&aacute; que acceder con el fin de resolver el problema, y determine c&oacute;mo accederlos. Puede utilizar Firebug para verificar que esta obteniendo el resultado esperado.
              </p>
            </li>
            <li>
              <p>
                Finalmente, averigüe qu&eacute; necesita hacer con esos elementos para resolver el problema. Puede ser &uacute;til, antes de comenzar, escribir comentarios explicando lo que va a realizar.
              </p>
            </li>
          </ul>
          <p>
            No tenga miedo de cometer errores. Tampoco trate en el primer intento escribir de forma perfecta su c&oacute;digo. Cometer errores y experimentar con soluciones es parte del proceso de aprendizaje y lo ayudar&aacute; a que sea un mejor desarrollador.
          </p>
          <p>
			Podr&aacute; encontrar en la carpeta <code>/solutions</code> ejemplos de soluciones a los ejercicios del libro.
          </p>
        </div>
        <h2>Convenciones Utilizadas en el Libro</h2>
        <p>
          Existen una serie de convenciones utilizadas en el libro:
        </p>
        <p>
          Los m&eacute;todos que pueden ser llamados desde el objeto jQuery, ser&aacute;n referenciados como <code>$.fn.nombreDelMetodo</code>. Los m&eacute;todos que existen en el espacio de nombres (en ingl&eacute;s <em>namespace</em>) de jQuery pero que no pueden ser llamados desde el objeto jQuery ser&aacute;n referenciados como <code>$.nombreDelMetodo</code>. Si esto no significa mucho para usted, no se preocupe — ser&aacute; m&aacute;s claro a medida que vaya progresando en el libro.
        </p>
        <div class="example">
          <p class="title">
            <b>Ejemplo de un c&oacute;digo</b>
          </p>
          <div class="example-contents">
            <pre class="brush: js">
// el c&oacute;digo de ejemplo aparecer&aacute; de esta forma
</pre>
          </div>
        </div>
        <p class="remark">
          <i><span class="remark">Las remarcaciones aparecer&aacute;n de esta forma.</span></i>
        </p>
        <div class="note">
        <h3>
          Nota
        </h3>
        <p>
          Las notas sobre alg&uacute;n tema aparecer&aacute;n de esta forma.
        </p>
        </div>
        <div title="Notas de la Traducci&oacute;n" class="section">
          <h2>Notas de la Traducci&oacute;n</h2>
          <ul>
            <li>
              <p>
                Debido a que el material tiene como fin el aprendizaje y la ense&ntilde;anza, el mismo se encuentra traducido a espa&ntilde;ol formal (usted).
              </p>
            </li>
            <li>
              <p>
                Muchos conceptos t&eacute;cnicos son nombrados en su versi&oacute;n traducida a espa&ntilde;ol. Sin embargo, para tener de referencia, tambi&eacute;n se explica como es llamado en ingl&eacute;s.
              </p>
            </li>
            <li>
              <p>
                Los ejemplos y soluciones a ejercicios no est&aacute;n completamente traducidos. Esto es debido a que, cuando est&eacute; trabajando en un proyecto real, el c&oacute;digo que encuentre en otros sitios probablemente est&eacute; en ingl&eacute;s. A&uacute;n as&iacute;, se han traducido los comentarios incorporados en los c&oacute;digos de ejemplos y algunos textos particulares para facilitar la comprensi&oacute;n.
              </p>
            </li>
          </ul>
        </div>
        <div title="Material de Referencia" class="section">
          <h2>Material de Referencia</h2>
          <p>
            Existe una gran cantidad de art&iacute;culos que se ocupan de alg&uacute;n aspecto de jQuery. Algunos son excelentes pero otros, francamente, son err&oacute;neos. Cuando lea un art&iacute;culo sobre jQuery, este seguro que se est&aacute; abarcando la misma versi&oacute;n de la biblioteca que est&aacute; utilizando, y res&iacute;stase a la tentaci&oacute;n de copiar y pegar el c&oacute;digo — t&oacute;mese un tiempo para poder entenderlo.
          </p>
          <p>
			A continuaci&oacute;n se listan una serie de excelentes recursos para utilizar durante el aprendizaje. El m&aacute;s importante de todos es el c&oacute;digo fuente de jQuery, el cual contiene (en su formato sin comprimir) una completa documentaci&oacute;n a trav&eacute;s de comentarios. La biblioteca no es una caja negra — el entendimiento de ella ir&aacute; increment&aacute;ndose exponencialmente si la revisa de vez en cuando — y es muy recomendable que la guarde en los favoritos de su navegador para tenerla como gu&iacute;a de referencia.
          </p>
          <ul>
            <li>
              <p>
                <a href="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js" rel="_blank">El c&oacute;digo fuente de jQuery</a>
              </p>
            </li>
            <li>
              <p>
                <a href="http://api.jquery.com" rel="_blank">Documentaci&oacute;n de jQuery</a>
              </p>
            </li>
            <li>
              <p>
                <a href="http://forum.jquery.com/" rel="_blank">Foro de jQuery</a>
              </p>
            </li>
            <li>
              <p>
                <a href="http://delicious.com/rdmey/jquery-class" rel="_blank">Favoritos en Delicious</a>
              </p>
            </li>
            <li>
              <p>
                <a href="http://docs.jquery.com/Discussion#Chat_.2F_IRC_Channel" rel="_blank">Canal IRC #jquery en Freenode</a>
              </p>
            </li>
          </ul>
        </div>
      </div>  		<div title="Parte I. JavaScript 101">
			<h1 class="title">Parte I. JavaScript 101</h1>
			         <div id="capitulo-2" title="Conceptos B&aacute;sicos de JavaScript" class="chapter">
			<h2 class="title">Conceptos B&aacute;sicos de JavaScript</h2>
          <div title="Introducci&oacute;n" class="section">
            <h2>Introducci&oacute;n</h2>
            <p>
              jQuery se encuentra escrito en JavaScript, un lenguaje de programaci&oacute;n muy rico y expresivo. 
            </p>
            <p>
              El cap&iacute;tulo est&aacute; orientado a personas sin experiencia en el lenguaje, abarcando conceptos b&aacute;sicos y problemas frecuentes que pueden presentarse al trabajar con el mismo. Por otro lado, la secci&oacute;n puede ser beneficiosa para quienes utilicen otros lenguajes de programaci&oacute;n para entender las peculiaridades de JavaScript.
            </p>
            <p>
              Si usted esta interesado en aprender el lenguaje m&aacute;s en profundidad, puede leer el libro <em class="citetitle">JavaScript: The Good Parts</em> escrito por Douglas Crockford.
            </p>
          </div>
          <div title="Sintaxis B&aacute;sica" class="section">
            <h2>Sintaxis B&aacute;sica</h2>
            <p>
              Comprensi&oacute;n de declaraciones, nombres de variables, espacios en blanco, y otras sintaxis b&aacute;sicas de JavaScript.
            </p>
            <div class="example">
              <p class="title">
                <b>Declaraci&oacute;n simple de variable</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = 'hello world';
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Los espacios en blanco no tienen valor fuera de las comillas</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo =         'hello world';
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Los par&eacute;ntesis indican prioridad</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
2 * 3 + 5;    // es igual a 11; la multiplicaci&oacute;n ocurre primero
2 * (3 + 5);  // es igual a 16; por lo parentesis, la suma ocurre primero
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>La tabulaci&oacute;n mejora la lectura del c&oacute;digo, pero no posee ning&uacute;n significado especial</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = function() {
    console.log('hello');
};
</pre>
              </div>
            </div>
          </div>
          <div title="Operadores" class="section">
            <h2>Operadores</h2>
            <div title="Operadores B&aacute;sicos" class="section">
                <h3>
                  Operadores B&aacute;sicos
                </h3>
              <p>
                Los operadores b&aacute;sicos permiten manipular valores.
              </p>
              <div class="example">
                <p class="title">
                  <b>Concatenaci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var foo = 'hello';
var bar = 'world';

console.log(foo + ' ' + bar); // la consola de depuraci&oacute;n muestra 'hello world'
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Multiplicaci&oacute;n y divisi&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
2 * 3;
2 / 3;
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Incrementaci&oacute;n y decrementaci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var i = 1;

var j = ++i;  // incrementaci&oacute;n previa:  j es igual a 2; i es igual a 2
var k = i++;  // incrementaci&oacute;n posterior: k es igual a 2; i es igual a 3
</pre>
                </div>
              </div>
            </div>
            <div title="Operaciones con N&uacute;meros y Cadenas de Caracteres" class="section">
                <h3>
                  Operaciones con N&uacute;meros y Cadenas de Caracteres
                </h3>
              <p>
                En JavaScript, las operaciones con n&uacute;meros y cadenas de caracteres (en ingl&eacute;s <em>strings</em>) pueden ocasionar resultados no esperados.
              </p>
              <div class="example">
                <p class="title">
                  <b>Suma vs. concatenaci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var foo = 1;
var bar = '2';

console.log(foo + bar);  // error: La consola de depuraci&oacute;n muestra 12
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Forzar a una cadena de caracteres actuar como un n&uacute;mero</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var foo = 1;
var bar = '2';

// el constructor 'Number' obliga a la cadena comportarse como un n&uacute;mero
console.log(foo + Number(bar));  // la consola de depuraci&oacute;n muestra 3
</pre>
                </div>
              </div>
              <p>
                El constructor <em class="firstterm">Number</em>, cuando es llamado como una funci&oacute;n (como se muestra en el ejemplo) obliga a su argumento a comportarse como un n&uacute;mero. Tambi&eacute;n es posible utilizar el operador de <em>suma unaria</em>, entregando el mismo resultado:
              </p>
              <div class="example">
                <p class="title">
                  <b>Forzar a una cadena de caracteres actuar como un n&uacute;mero (utilizando el operador de suma unaria)</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
console.log(foo + +bar);
</pre>
                </div>
              </div>
            </div>
              <h3>
                Operadores L&oacute;gicos
              </h3>
            <p>
              Los operadores l&oacute;gicos permiten evaluar una serie de operandos utilizando operaciones AND y OR.
            </p>
            <div class="example">
              <p class="title">
                <b>Operadores l&oacute;gicos AND y OR</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = 1;
var bar = 0;
var baz = 2;

foo || bar;   // devuelve 1, el cual es verdadero (true)
bar || foo;   // devuelve 1, el cual es verdadero (true)

foo &amp;&amp; bar;   // devuelve 0, el cual es falso (false)
foo &amp;&amp; baz;   // devuelve 2, el cual es verdadero (true)
baz &amp;&amp; foo;   // devuelve 1, el cual es verdadero (true)
</pre>
              </div>
            </div>
            <p>
              El operador <code>||</code> (OR l&oacute;gico) devuelve el valor del primer operando, si &eacute;ste es verdadero; caso contrario devuelve el segundo operando. Si ambos operandos son falsos devuelve falso (<em>false</em>). El operador <code>&&</code> (AND l&oacute;gico) devuelve el valor del primer operando si &eacute;ste es falso; caso contrario devuelve el segundo operando. Cuando ambos valores son verdaderos devuelve verdadero (<em>true</em>), sino devuelve falso.
            </p>
            <p>
			  Puede consultar la secci&oacute;n <a title="Elementos Verdaderos y Falsos" href="#Elementos Verdaderos y Falsos" class="xref">"Elementos Verdaderos y Falsos"</a> para m&aacute;s detalles sobre que valores se eval&uacute;an como <code>true</code> y cuales se eval&uacute;an como <code>false</code>.
            </p>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              Puede que a veces note que algunos desarrolladores utilizan esta l&oacute;gica en flujos de control en lugar de utilizar la declaraci&oacute;n <code>if</code>. Por ejemplo:
            </p>
            <pre class="brush: js">
// realizar algo con foo si foo es verdadero
foo &amp;&amp; doSomething(foo);

// establecer bar igual a baz si baz es verdadero;
// caso contrario, establecer a bar igual al
// valor de createBar()
var bar = baz || createBar();
</pre>
            <p>
              Este estilo de declaraci&oacute;n es muy elegante y conciso; pero puede ser dif&iacute;cil para leer (sobretodo para principiantes). Por eso se explicita, para reconocerlo cuando este leyendo c&oacute;digo. Sin embargo su utilizaci&oacute;n no es recomendable a menos que est&eacute; c&oacute;modo con el concepto y su comportamiento.
            </p>
            </div>
            <div title="Operadores de Comparaci&oacute;n" class="section">
                <h3>
                  Operadores de Comparaci&oacute;n
                </h3>
              <p>
                Los operadores de comparaci&oacute;n permiten comprobar si determinados valores son equivalentes o id&eacute;nticos.
              </p>
              <div class="example">
                <p class="title">
                  <b>Operadores de Comparaci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var foo = 1;
var bar = 0;
var baz = '1';
var bim = 2;

foo == bar;   // devuelve falso (false)
foo != bar;   // devuelve verdadero (true)
foo == baz;   <span class="bold"><strong>// devuelve verdadero (true); tenga cuidado</strong></span>

foo === baz;             // devuelve falso (false)
foo !== baz;             // devuelve verdadero (true)
foo === parseInt(baz);   // devuelve verdadero (true)

foo &gt; bim;    // devuelve falso (false)
bim &gt; baz;    // devuelve verdadero (true)
foo &lt;= baz;   // devuelve verdadero (true)
</pre>
                </div>
              </div>
            </div>
          </div>
          <h2>C&oacute;digo Condicional</h2>
            A veces se desea ejecutar un bloque de c&oacute;digo bajo ciertas condiciones. Las estructuras de control de flujo — a trav&eacute;s de la utilizaci&oacute;n de las declaraciones <code>if</code> y <code>else</code> permiten hacerlo.
          <p>
          </p>
          <div class="example">
            <p class="title">
              <b>Control del flujo</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var foo = true;
var bar = false;

if (bar) {
    // este c&oacute;digo nunca se ejecutar&aacute;
    console.log('hello!');
}

if (bar) {
    // este c&oacute;digo no se ejecutar&aacute;
} else {
    if (foo) {
        // este c&oacute;digo se ejecutar&aacute;
    } else {
        // este c&oacute;digo se ejecutar&aacute; si foo y bar son falsos (false)
    }
}
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            En una l&iacute;nea singular, cuando se escribe una declaraci&oacute;n <code>if</code>, las llaves no son estrictamente necesarias; sin embargo es recomendable su utilizaci&oacute;n, ya que hace que el c&oacute;digo sea mucho m&aacute;s legible.
          </p>
          <p>
            Debe tener en cuenta de no definir funciones con el mismo nombre m&uacute;ltiples veces dentro de declaraciones <code>if</code>/<code>else</code>, ya que puede obtener resultados no esperados.
          </p>
          </div>

          <div title="Elementos Verdaderos y Falsos" id="Elementos Verdaderos y Falsos" class="section">
              <h3>
                Elementos Verdaderos y Falsos
              </h3>
            <p>
              Para controlar el flujo adecuadamente, es importante entender qu&eacute; tipos de valores son "verdaderos" y cuales "falsos". A veces, algunos valores pueden parecer una cosa pero al final terminan siendo otra.
            </p>
            <div class="example">
              <p class="title">
                <b>Valores que devuelven <code>verdadero (true)</code></b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
'0';
'any string'; // cualquier cadena
[];  // un arreglo vac&iacute;o
{};  // un objeto vac&iacute;o
1;   // cualquier n&uacute;mero distinto a cero
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Valores que devuelven <code>falso (false)</code></b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
0;
'';  // una cadena vac&iacute;a
NaN; // la variable JavaScript "not-a-number" (No es un n&uacute;mero)
null; // un valor nulo
undefined;  // tenga cuidado -- indefinido (undefined) puede ser redefinido
</pre>
              </div>
            </div>
          </div>
          <div title="Variables Condicionales Utilizando el Operador Ternario" class="section">
              <h3>
                Variables Condicionales Utilizando el Operador Ternario
              </h3>
            <p>
              A veces se desea establecer el valor de una variable dependiendo de cierta condici&oacute;n. Para hacerlo se puede utilizar una declaraci&oacute;n <code>if</code>/<code>else</code>, sin embargo en muchos casos es m&aacute;s conveniente utilizar el operador ternario. <span class="termdef">[Definici&oacute;n: El <em class="firstterm">operador ternario</em> eval&uacute;a una condici&oacute;n; si la condici&oacute;n es verdadera, devuelve cierto valor, caso contrario devuelve un valor diferente.]</span>
            </p>
            <div class="example">
              <p class="title">
                <b>El operador ternario</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
// establecer a foo igual a 1 si bar es verdadero;
// caso contrario, establecer a foo igual a 0
var foo = bar ? 1 : 0;
</pre>
              </div>
            </div>
            <p>
              El operador ternario puede ser utilizado sin devolver un valor a la variable, sin embargo este uso generalmente es desaprobado.
            </p>
          </div>
          <div title="Declaraci&oacute;n Switch" class="section">
              <h3>
                Declaraci&oacute;n Switch
              </h3>
            <p>
              En lugar de utilizar una serie de declaraciones if/else/else if/else, a veces puede ser &uacute;til la utilizaci&oacute;n de la declaraci&oacute;n switch. <span class="termdef">[Definici&oacute;n: La declaraci&oacute;n <em class="firstterm">Switch</em> eval&uacute;a el valor de una variable &oacute; expresi&oacute;n, y ejecuta diferentes bloques de c&oacute;digo dependiendo de ese valor.]</span>
            </p>
            <div class="example">
              <p class="title">
                <b>Una declaraci&oacute;n Switch</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
switch (foo) {

    case 'bar':
        alert('el valor es bar');
    break;

    case 'baz':
        alert('el valor es baz');
    break;

    default:
        alert('de forma predeterminada se ejecutar&aacute; este c&oacute;digo');
    break;

}
</pre>
              </div>
            </div>
            <p>
              Las declaraciones switch son poco utilizadas en JavaScript, debido a que el mismo comportamiento es posible obtenerlo creando un objeto, el cual posee m&aacute;s potencial ya que es posible reutilizarlo, usarlo para realizar pruebas, etc. Por ejemplo:
            </p>
            <pre class="brush: js">
var stuffToDo = {
    'bar' : function() {
        alert('el valor es bar');
    },

    'baz' : function() {
        alert('el valor es baz');
    },

    'default' : function() {
        alert('de forma predeterminada se ejecutar&aacute; este c&oacute;digo');
    }
};

if (stuffToDo[foo]) {
    stuffToDo[foo]();
} else {
    stuffToDo['default']();
}
</pre>
            <p>
              M&aacute;s adelante se abarcar&aacute; el concepto de objetos.
            </p>
          </div>
          <div title="Bucles" class="section">
            <h2>Bucles</h2>
            <p>
              Los bucles (en ingl&eacute;s <em>loops</em>) permiten ejecutar un bloque de c&oacute;digo un determinado n&uacute;mero de veces.
            </p>
            <div class="example">
              <p class="title">
                <b>Bucles</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
// muestra en la consola 'intento 0', 'intento 1', ..., 'intento 4'
for (var i=0; i&lt;5; i++) {
    console.log('intento ' + i);
}
</pre>
              </div>
            </div>
            <p>
              <em><span class="remark">Note que en el ejemplo </span></em> <em>se utiliza la palabra <span class="token">var</span> antes de la variable <code class="varname">i</code>, esto hace que dicha variable quede dentro del "alcance" (en ingl&eacute;s <em>scope</em>) del bucle. M&aacute;s adelante en este cap&iacute;tulo se examinar&aacute; en profundidad el concepto de alcance.</em>
            </p>
            <div title="Bucles Utilizando For" class="section">
                <h3>
                  Bucles Utilizando For
                </h3>
              <p>
                Un bucle utilizando <code>for</code> se compone de cuatro estados y posee la siguiente estructura:
              </p>
              <pre class="brush: js">
for ([expresi&oacute;nInicial]; [condici&oacute;n]; [incrementoDeLaExpresi&oacute;n])
 [cuerpo]
</pre>
              <p>
                El estado <em>expresi&oacute;nInicial</em> es ejecutado una sola vez, antes que el bucle comience. &eacute;ste otorga la oportunidad de preparar o declarar variables.
              </p>
              <p>
				El estado <em>condici&oacute;n</em> es ejecutado antes de cada repetici&oacute;n, y retorna un valor que decide si el bucle debe continuar ejecut&aacute;ndose o no. Si el estado condicional eval&uacute;a un valor falso el bucle se detiene.
              </p>
              <p>
				El estado <em>incrementoDeLaExpresi&oacute;n</em> es ejecutado al final de cada repetici&oacute;n y otorga la oportunidad de cambiar el estado de importantes variables. Por lo general, este estado implica la incrementaci&oacute;n o decrementaci&oacute;n de un contador.
              </p>
              <p>
                El <em>cuerpo</em> es el c&oacute;digo a ejecutar en cada repetici&oacute;n del bucle.
              </p>
              <div class="example">
                <p class="title">
                  <b>Un t&iacute;pico bucle utilizando <code>for</code></b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
for (var i = 0, limit = 100; i &lt; limit; i++) {
    // Este bloque de c&oacute;digo ser&aacute; ejecutado 100 veces
    console.log('Currently at ' + i);
    // Nota: el &uacute;ltimo registro que se mostrar&aacute; en la consola ser&aacute; "Actualmente en 99"
}
</pre>
                </div>
              </div>
            </div>
            <div title="Bucles Utilizando While" class="section">
                <h3>
                  Bucles Utilizando While
                </h3>
              <p>
				Un bucle utilizando <code>while</code> es similar a una declaraci&oacute;n condicional <code>if</code>, excepto que el cuerpo va a continuar ejecut&aacute;ndose hasta que la condici&oacute;n a evaluar sea falsa.
              </p>
              <pre class="brush: js">
while ([condici&oacute;n]) [cuerpo]
</pre>
              <div class="example">
                <p class="title">
                  <b>Un t&iacute;pico bucle utilizando <code>while</code></b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var i = 0;
while (i &lt; 100) {

    // Este bloque de c&oacute;digo se ejecutar&aacute; 100 veces
    console.log('Actualmente en ' + i);

    i++; // incrementa la variable i

}
</pre>
                </div>
              </div>
              <p>
                Puede notar que en el ejemplo se incrementa el contador dentro del cuerpo del bucle, pero tambi&eacute;n es posible combinar la condici&oacute;n y la incrementaci&oacute;n, como se muestra a continuaci&oacute;n:
              </p>
              <div class="example">
                <p class="title">
                  <b>Bucle utilizando <code>while</code> con la combinaci&oacute;n de la condici&oacute;n y la incrementaci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var i = -1;
while (++i &lt; 100) {
    // Este bloque de c&oacute;digo se ejecutar&aacute; 100 veces
    console.log('Actualmente en ' + i);
}
</pre>
                </div>
              </div>
              <p>
				Se comienza en <code>-1</code> y luego se utiliza la incrementaci&oacute;n previa (<code>++i</code>).
              </p>
            </div>
            <div title="Bucles Utilizando Do-while" class="section">
                <h3>
                  Bucles Utilizando Do-while
                </h3>
              <p>
                Este bucle es exactamente igual que el bucle utilizando <code>while</code> excepto que el cuerpo es ejecutado al menos una vez antes que la condici&oacute;n sea evaluada.
              </p>
              <pre class="brush: js">
do [cuerpo] while ([condici&oacute;n])
</pre>
              <div class="example">
                <p class="title">
                  <b>Un bucle utilizando <code>do-while</code></b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
do {

    // Incluso cuando la condici&oacute;n sea falsa
    // el cuerpo del bucle se ejecutar&aacute; al menos una vez.

    alert('Hello');

} while (false);
</pre>
                </div>
              </div>
              <p>
                Este tipo de bucles son bastantes at&iacute;picos ya que en pocas ocasiones de necesita un bucle que se ejecute al menos una vez. De cualquier forma debe estar al tanto de ellos.
              </p>
            </div>
            <div title="Break y Continue" class="section">
                <h3>
                  Break y Continue
                </h3>
              <p>
				Usualmente, el fin de la ejecuci&oacute;n de un bucle resultar&aacute; cuando la condici&oacute;n no siga evaluando un valor verdadero, sin embargo tambi&eacute;n es posible parar un bucle utilizando la declaraci&oacute;n <code>break</code> dentro del cuerpo.
              </p>
              <div class="example">
                <p class="title">
                  <b>Detener un bucle con break</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
for (var i = 0; i &lt; 10; i++) {
    if (something) {
        break;
    }
}
</pre>
                </div>
              </div>
              <p>
				Tambi&eacute;n puede suceder que quiera continuar con el bucle sin tener que ejecutar m&aacute;s sentencias del cuerpo del mismo bucle. Esto puede realizarse utilizando la declaraci&oacute;n <code>continue</code>.
              </p>
              <div class="example">
                <p class="title">
                  <b>Saltar a la siguiente iteraci&oacute;n de un bucle</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
for (var i = 0; i &lt; 10; i++) {

    if (something) {
        continue;
    }

    // La siguiente declaraci&oacute;n ser&aacute; ejecutada
    // si la condici&oacute;n 'something' no se cumple
    console.log('Hello');

}
</pre>
                </div>
              </div>
            </div>
          </div>
          <div title="Palabras Reservadas" class="section">
            <h2>Palabras Reservadas</h2>
            <p>
              JavaScript posee un n&uacute;mero de "palabras reservadas", o palabras que son especiales dentro del mismo lenguaje. Debe utilizar estas palabras cuando las necesite para su uso espec&iacute;fico.
            </p>
            <ul>
                <li>
                  <code>abstract</code>
                </li>
                <li>
                  <code>boolean</code>
                </li>
                <li>
                  <code>break</code>
                </li>
                <li>
                  <code>byte</code>
                </li>
                <li>
                  <code>case</code>
                </li>
                <li>
                  <code>catch</code>
                </li>
                <li>
                  <code>char</code>
                </li>
                <li>
                  <code>class</code>
                </li>
                <li>
                  <code>const</code>
                </li>
                <li>
                  <code>continue</code>
                </li>
                <li>
                  <code>debugger</code>
                </li>
                <li>
                  <code>default</code>
                </li>
                <li>
                  <code>delete</code>
                </li>
                <li>
                  <code>do</code>
                </li>
                <li>
                  <code>double</code>
                </li>
                <li>
                  <code>else</code>
                </li>
                <li>
                  <code>enum</code>
                </li>
                <li>
                  <code>export</code>
                </li>
                <li>
                  <code>extends</code>
                </li>
                <li>
                  <code>final</code>
                </li>
                <li>
                  <code>finally</code>
                </li>
                <li>
                  <code>float</code>
                </li>
                <li>
                  <code>for</code>
                </li>
                <li>
                  <code>function</code>
                </li>
                <li>
                  <code>goto</code>
                </li>
                <li>
                  <code>if</code>
                </li>
                <li>
                  <code>implements</code>
                </li>
                <li>
                  <code>import</code>
                </li>
                <li>
                  <code>in</code>
                </li>
                <li>
                  <code>instanceof</code>
                </li>
                <li>
                  <code>int</code>
                </li>
                <li>
                  <code>interface</code>
                </li>
                <li>
                  <code>long</code>
                </li>
                <li>
                  <code>native</code>
                </li>
                <li>
                  <code>new</code>
                </li>
                <li>
                  <code>package</code>
                </li>
                <li>
                  <code>private</code>
                </li>
                <li>
                  <code>protected</code>
                </li>
                <li>
                  <code>public</code>
                </li>
                <li>
                  <code>return</code>
                </li>
                <li>
                  <code>short</code>
                </li>
                <li>
                  <code>static</code>
                </li>
                <li>
                  <code>super</code>
                </li>
                <li>
                  <code>switch</code>
                </li>
                <li>
                  <code>synchronized</code>
                </li>
                <li>
                  <code>this</code>
                </li>
                <li>
                  <code>throw</code>
                </li>
                <li>
                  <code>throws</code>
                </li>
                <li>
                  <code>transient</code>
                </li>
                <li>
                  <code>try</code>
                </li>
                <li>
                  <code>typeof</code>
                </li>
                <li>
                  <code>var</code>
                </li>
                <li>
                  <code>void</code>
                </li>
                <li>
                  <code>volatile</code>
                </li>
                <li>
                  <code>while</code>
                </li>
                <li>
                  <code>with</code>
                </li>
            </ul>
          </div>
          <div title="Arreglos" class="section">
            <h2>Arreglos</h2>
            <p>
			  Los arreglos (en ingl&eacute;s <em>arrays</em>) son listas de valores con &iacute;ndice-cero (en ingl&eacute;s <em>zero-index</em>), es decir, que el primer elemento del arreglo est&aacute; en el &iacute;ndice 0. &Eacute;stos son una forma pr&aacute;ctica de almacenar un conjunto de datos relacionados (como cadenas de caracteres), aunque en realidad, un arreglo puede incluir m&uacute;ltiples tipos de datos, incluso otros arreglos.
            </p>
            <div class="example">
              <p class="title">
                <b>Un arreglo simple</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myArray = [ 'hello', 'world' ];
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Acceder a los &iacute;tems del arreglo a trav&eacute;s de su &iacute;ndice</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myArray = [ 'hello', 'world', 'foo', 'bar' ];
console.log(myArray[3]);   // muestra en la consola 'bar'
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Obtener la cantidad de &iacute;tems del arreglo</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myArray = [ 'hello', 'world' ];
console.log(myArray.length);   // muestra en la consola 2
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Cambiar el valor de un &iacute;tem de un arreglo</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myArray = [ 'hello', 'world' ];
myArray[1] = 'changed';
</pre>
              </div>
            </div>
            <p class="remark">
              <i><span class="remark">Como se muestra en el ejemplo</span> "Cambiar el valor de un &iacute;tem de un arreglo" es posible cambiar el valor de un &iacute;tem de un arreglo, sin embargo, por lo general, no es aconsejable.</i>
            </p>
            <div class="example">
              <p class="title">
                <b>A&ntilde;adir elementos a un arreglo</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myArray = [ 'hello', 'world' ];
myArray.push('new');
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Trabajar con arreglos</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myArray = [ 'h', 'e', 'l', 'l', 'o' ];
var myString = myArray.join('');   // 'hello'
var mySplit = myString.split('');  // [ 'h', 'e', 'l', 'l', 'o' ]
</pre>
              </div>
            </div>
          </div>
          <h2>Objetos</h2>
          <p>
            Los objetos son elementos que pueden contener cero o m&aacute;s conjuntos de pares de nombres claves y valores asociados a dicho objeto. Los nombres claves pueden ser cualquier palabra &oacute; n&uacute;mero v&aacute;lido. El valor puede ser cualquier tipo de valor: un n&uacute;mero, una cadena, un arreglo, una funci&oacute;n, incluso otro objeto.
          </p>
          <p>
            <span class="termdef">[Definici&oacute;n: Cuando uno de los valores de un objeto es una funci&oacute;n, &eacute;sta es nombrada como un <em class="firstterm">m&eacute;todo</em> del objeto.]</span> De lo contrario, se los llama <em class="firstterm">propiedades</em>.
          </p>
          <p>
            Curiosamente, en JavaScript, casi todo es un objeto — arreglos, funciones, n&uacute;meros, incluso cadenas — y todos poseen propiedades y m&eacute;todos.
          </p>
          <div class="example">
            <p class="title">
              <b>Creaci&oacute;n de un "objeto literal"</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var myObject = {
    sayHello : function() {
        console.log('hello');
    },

    myName : 'Rebecca'
};

myObject.sayHello();            // se llama al m&eacute;todo sayHello, el cual muestra en la consola 'hello'
console.log(myObject.myName);   // se llama a la propiedad myName, la cual muestra en la consola 'Rebecca'
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Notar que cuando se crean objetos literales, el nombre de la propiedad puede ser cualquier identificador JavaScript, una cadena de caracteres (encerrada entre comillas) &oacute; un n&uacute;mero:
          </p>
          <pre class="brush: js">
var myObject = {
    validIdentifier: 123,
    'some string': 456,
    99999: 789
};
</pre>
          <p>
            Los objetos literales pueden ser muy &uacute;tiles para la organizaci&oacute;n del c&oacute;digo, para m&aacute;s informaci&oacute;n puede leer el art&iacute;culo (en ingl&eacute;s) <a href="http://blog.rebeccamurphey.com/2009/10/15/using-objects-to-organize-your-code/">Using Objects to Organize Your Code</a> por Rebecca Murphey.
          </p>
          </div>
          <div title="Funciones" class="section">
            <h2>Funciones</h2>
            <p>
              Las funciones contienen bloques de c&oacute;digo que se ejecutaran repetidamente. A las mismas se le pueden pasar argumentos, y opcionalmente la funci&oacute;n puede devolver un valor.
            </p>
            <p>
              Las funciones pueden ser creadas de varias formas:
            </p>
            <div class="example">
              <p class="title">
                <b>Declaraci&oacute;n de una funci&oacute;n</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
function foo() { /* hacer algo */ }
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Declaraci&oacute;n de una funci&oacute;n nombrada</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = function() { /* hacer algo */ }
</pre>
              </div>
            </div>
            <p class="remark">
			  <i><span class="remark">Es preferible el m&eacute;todo de funci&oacute;n nombrada debido a algunas</span></i> <i><a href="http://yura.thinkweb2.com/named-function-expressions/">profundas razones t&eacute;cnicas</a>. Igualmente, es probable encontrar a los dos m&eacute;todos cuando se revise c&oacute;digo JavaScript.</i>
            </p>
            <div title="Utilizaci&oacute;n de Funciones" class="section">
                <h3>
                  Utilizaci&oacute;n de Funciones
                </h3>
              <div class="example">
                <p class="title">
                  <b>Una funci&oacute;n simple</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var greet = function(person, greeting) {
    var text = greeting + ', ' + person;
    console.log(text); 
};


greet('Rebecca', 'Hello');  // muestra en la consola 'Hello, Rebecca'
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Una funci&oacute;n que devuelve un valor</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var greet = function(person, greeting) {
    var text = greeting + ', ' + person;
    return text;
};

console.log(greet('Rebecca','hello'));  // la funci&oacute;n devuelve 'Hello, Rebecca', la cual se muestra en la consola
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Una funci&oacute;n que devuelve otra funci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var greet = function(person, greeting) {
    var text = greeting + ', ' + person;
    return function() { console.log(text); };
};


var greeting = greet('Rebecca', 'Hello');
greeting();  // se muestra en la consola 'Hello, Rebecca'
</pre>
                </div>
              </div>
            </div>
            <div title="Self-Executing Anonymous Functions" class="section">
                <h3>
                  Funciones An&oacute;nimas Autoejecutables
                </h3>
              <p>
				Un patr&oacute;n com&uacute;n en JavaScript son las funciones an&oacute;nimas autoejecutables. Este patr&oacute;n consiste en crear una expresi&oacute;n de funci&oacute;n e inmediatamente ejecutarla. El mismo es muy &uacute;til para casos en que no se desea intervenir espacios de nombres globales, debido a que ninguna variable declarada dentro de la funci&oacute;n es visible desde afuera.
              </p>
              <div class="example">
                <p class="title">
                  <b>Funci&oacute;n an&oacute;nima autoejecutable</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
(function(){
    var foo = 'Hello world';
})();


console.log(foo);   // indefinido (undefined)
</pre>
                </div>
              </div>
            </div>
            <div title="Funciones como Argumentos" class="section">
                <h3>
                  Funciones como Argumentos
                </h3>
              <p>
				En JavaScript, las funciones son "ciudadanos de primera clase" &mdash; pueden ser asignadas a variables o pasadas a otras funciones como argumentos. En jQuery, pasar funciones como argumentos es una pr&aacute;ctica muy com&uacute;n.
              </p>
              <div class="example">
                <p class="title">
                  <b>Pasar una funci&oacute;n an&oacute;nima como un argumento</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var myFn = function(fn) {
    var result = fn();
    console.log(result);
};

myFn(function() { return 'hello world'; });   // muestra en la consola 'hello world'
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Pasar una funci&oacute;n nombrada como un argumento</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var myFn = function(fn) {
    var result = fn();
    console.log(result);
};

var myOtherFn = function() {
    return 'hello world';
};

myFn(myOtherFn);   // muestra en la consola 'hello world'
</pre>
                </div>
              </div>
            </div>
          </div>
          <div title="Determinaci&oacute;n del Tipo de Variable" class="section">
            <h2>Determinaci&oacute;n del Tipo de Variable</h2>
            <p>
			  JavaScript ofrece una manera de poder comprobar el "tipo" (en ingl&eacute;s <em>type</em>) de una variable. 
			  Sin embargo, el resultado puede ser confuso &mdash; por ejemplo, el tipo de un arreglo es "object".
            </p>
            <p>
			  Por eso, es una pr&aacute;ctica com&uacute;n utilizar el operador <code>typeof</code> cuando se trata de determinar el tipo de un valor espec&iacute;fico.
            </p>
            <div class="example">
              <p class="title">
                <b>Determinar el tipo en diferentes variables</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myFunction = function() {
    console.log('hello');
};

var myObject = {
    foo : 'bar'
};

var myArray = [ 'a', 'b', 'c' ];

var myString = 'hello';

var myNumber = 3;

typeof myFunction;   // devuelve 'function'
typeof myObject;     // devuelve 'object'
typeof myArray;      // devuelve 'object' -- tenga cuidado
typeof myString;     // devuelve 'string'
typeof myNumber;     // devuelve 'number'

typeof null;         // devuelve 'object' -- tenga cuidado


if (myArray.push &amp;&amp; myArray.slice &amp;&amp; myArray.join) {
    // probablemente sea un arreglo
    // (este estilo es llamado, en ingl&eacute;s, "duck typing")
}

if (Object.prototype.toString.call(myArray) === '[object Array]') {
    // definitivamente es un arreglo;
    // esta es considerada la forma m&aacute;s robusta
    // de determinar si un valor es un arreglo.
}
</pre>
              </div>
            </div>
            <p>
              jQuery ofrece m&eacute;todos para ayudar a determinar el tipo de un determinado valor. Estos m&eacute;todos ser&aacute;n vistos m&aacute;s adelante.
            </p>
          </div>
          <h2>La palabra clave <code>this</code></h2>
          <p>
            En JavaScript, as&iacute; como en la mayor&iacute;a de los lenguajes de programaci&oacute;n orientados a objetos, <code>this</code> es una palabra clave especial que hace referencia al objeto en donde el m&eacute;todo est&aacute; siendo invocado. El valor de <code>this</code> es determinado utilizando una serie de simples pasos:
          </p>
          <div class="orderedlist">
            <ol class="orderedlist">
              <li>Si la funci&oacute;n es invocada utilizando <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">Function.call</a> &oacute; <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Function.apply</a>, <code>this</code> tendr&aacute; el valor del primer argumento pasado al m&eacute;todo. Si el argumento es nulo (<em>null</em>) &oacute; indefinido (<em>undefined</em>), <code>this</code> har&aacute; referencia el objeto global (el objeto <code>window</code>);
              </li>
              <li>Si la funci&oacute;n a invocar es creada utilizando <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.bind</a>, <code>this</code> ser&aacute; el primer argumento que es pasado a la funci&oacute;n en el momento en que se la crea;
              </li>
              <li>Si la funci&oacute;n es invocada como un m&eacute;todo de un objeto, <code>this</code> referenciar&aacute; a dicho objeto;
              </li>
              <li>De lo contrario, si la funci&oacute;n es invocada como una funci&oacute;n independiente, no unida a alg&uacute;n objeto, <code>this</code> referenciar&aacute; al objeto global.
              </li>
            </ol>
          </div>
          <div class="example">
            <p class="title">
              <b>Una funci&oacute;n invocada utilizando Function.call</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var myObject = {
    sayHello : function() {
        console.log('Hola, mi nombre es ' + this.myName);
    },

    myName : 'Rebecca'
};

var secondObject = {
    myName : 'Colin'
};

myObject.sayHello();                  // registra 'Hola, mi nombre es Rebecca'
myObject.sayHello.call(secondObject); // registra 'Hola, mi nombre es Colin'
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Una funci&oacute;n creada utilizando Function.bind</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var myName = 'el objeto global',

    sayHello = function () {
        console.log('Hola, mi nombre es ' + this.myName);
    },

    myObject = {
        myName : 'Rebecca'
    };

var myObjectHello = sayHello.bind(myObject);

sayHello();       // registra 'Hola, mi nombre es el objeto global'
myObjectHello();  // registra 'Hola, mi nombre es Rebecca'
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Una funci&oacute;n vinculada a un objeto</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var myName = 'el objeto global',

    sayHello = function() {
        console.log('Hola, mi nombre es ' + this.myName);
    },

    myObject = {
        myName : 'Rebecca'
    },

    secondObject = {
        myName : 'Colin'
    };

myObject.sayHello = sayHello;
secondObject.sayHello = sayHello;

sayHello();               // registra 'Hola, mi nombre es el objeto global'
myObject.sayHello();      // registra 'Hola, mi nombre es Rebecca'
secondObject.sayHello();  // registra 'Hola, mi nombre es Colin'
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            En algunas oportunidades, cuando se invoca una funci&oacute;n que se encuentra dentro de un espacio de nombres (en ingl&eacute;s <em>namespace</em>) amplio, puede ser una tentaci&oacute;n guardar la referencia a la funci&oacute;n actual en una variable m&aacute;s corta y accesible. Sin embargo, es importante no realizarlo en instancias de m&eacute;todos, ya que puede llevar a la ejecuci&oacute;n de c&oacute;digo incorrecto. Por ejemplo:
          </p>
          <pre class="brush: js">
var myNamespace = {
    myObject : {
        sayHello : function() {
            console.log('Hola, mi nombre es ' + this.myName);
        },

        myName : 'Rebecca'
    }
};

var hello = myNamespace.myObject.sayHello;

hello();  // registra 'Hola, mi nombre es undefined'
</pre>
          <p>
            Para que no ocurran estos errores, es necesario hacer referencia al objeto en donde el m&eacute;todo es invocado:
          </p>
          <pre class="brush: js">
var myNamespace = {
    myObject : {
        sayHello : function() {
            console.log('Hola, mi nombre es ' + this.myName);
        },

        myName : 'Rebecca'
    }
};

var obj = myNamespace.myObject;

obj.sayHello();  // registra 'Hola, mi nombre es Rebecca'
</pre>
          </div>
          <div title="Alcance" class="section">
            <h2>Alcance</h2>
            <p>
			  El "alcance" (en ingl&eacute;s <em>scope</em>) se refiere a las variables que est&aacute;n disponibles en un bloque de c&oacute;digo en un tiempo determinado. La falta de comprensi&oacute;n de este concepto puede llevar a una frustrante experiencia de depuraci&oacute;n.
            </p>
            <p>
			  Cuando una variable es declarada dentro de una funci&oacute;n utilizando la palabra clave <code
              class="code">var</code>, &eacute;sta &uacute;nicamente esta disponible para el c&oacute;digo dentro de la funci&oacute;n &mdash; todo el c&oacute;digo fuera de dicha funci&oacute;n no puede acceder a la variable. Por otro lado, las funciones definidas <em>dentro</em> de la funci&oacute;n <em>podr&aacute;n</em> acceder a la variable declarada.
            </p>
            <p>
			  Las variables que son declaradas dentro de la funci&oacute;n sin la palabra clave <code>var</code> no quedan dentro del &aacute;mbito de la misma funci&oacute;n &mdash; JavaScript buscar&aacute; el lugar en donde la variable fue previamente declarada, y en caso de no haber sido declarada, es definida dentro del alcance global, lo cual puede ocasionar consecuencias inesperadas;
            </p>
            <div class="example">
              <p class="title">
                <b>Funciones tienen acceso a variables definidas dentro del mismo alcance</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = 'hello';

var sayHello = function() {
    console.log(foo);
};

sayHello();         // muestra en la consola 'hello'
console.log(foo);   // tambi&eacute;n muestra en la consola 'hello'
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>El c&oacute;digo de afuera no tiene acceso a la variable definida dentro de la funci&oacute;n</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var sayHello = function() {
    var foo = 'hello';
    console.log(foo);
};

sayHello();         // muestra en la consola 'hello'
console.log(foo);   // no muestra nada en la consola
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Variables con nombres iguales pero valores diferentes pueden existir en diferentes alcances</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = 'world';

var sayHello = function() {
    var foo = 'hello';
    console.log(foo);
};

sayHello();         // muestra en la consola 'hello'
console.log(foo);   // muestra en la consola 'world'
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Las funciones pueden "ver" los cambios en las variables antes de que la funci&oacute;n sea definida</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myFunction = function() {
    var foo = 'hello';

    var myFn = function() {
        console.log(foo);
    };

    foo = 'world';

    return myFn;
};

var f = myFunction();
f();  // registra 'world' -- error
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Alcance</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
// una funci&oacute;n anonima autoejecutable
(function() {
    var baz = 1;
    var bim = function() { alert(baz); };
    bar = function() { alert(baz); };
})();

console.log(baz);  // La consola no muestra nada, ya que baz esta definida dentro del alcance de la funci&oacute;n anonima

bar();  // bar esta definido fuera de la funci&oacute;n anonima
        // ya que fue declarada sin la palabra clave var; adem&aacute;s,
        // como fue definida dentro del mismo alcance que baz,
        // se puede consultar el valor de baz a pesar que 
        // &eacute;sta este definida dentro del alcance de la funci&oacute;n anonima

bim();  // bim no esta definida para ser accesible fuera de la funci&oacute;n anonima,
        // por lo cual se mostrar&aacute; un error
</pre>
              </div>
            </div>
          </div>
          <div title="Clausuras" class="section">
            <h2>Clausuras</h2>
            <p>
			  Las clausuras (en ingl&eacute;s <em>closures</em>) son una extensi&oacute;n del concepto de alcance (<em>scope</em>) — funciones que tienen acceso a las variables que est&aacute;n disponibles dentro del &aacute;mbito en donde se cre&oacute; la funci&oacute;n. Si este concepto es confuso, no debe preocuparse: se entiende mejor a trav&eacute;s de ejemplos.
            </p>
            <p>
			  En el ejemplo 2.47 se muestra la forma en que funciones tienen acceso para cambiar el valor de las variables. El mismo comportamiento sucede en funciones creadas dentro de bucles &mdash; la funci&oacute;n "observa" el cambio en la variable, incluso despu&eacute;s de que la funci&oacute;n sea definida, resultando que en todos los clicks aparezca una ventana de alerta mostrando el valor 5.
            </p>
            <div class="example">
              <p class="title">
                <b>¿C&oacute;mo establecer el valor de <code>i</code>?</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
/* esto no se comporta como se desea; */
/* cada click mostrar&aacute; una ventana de alerta con el valor 5 */
for (var i=0; i&lt;5; i++) {
    $('&lt;p&gt;hacer click&lt;/p&gt;').appendTo('body').click(function() {
        alert(i);
    });
}
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Establecer el valor de <code>i</code> utilizando una clausura</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
/* soluci&oacute;n: “clausurar” el valor de i dentro de createFunction */
var createFunction = function(i) {
    return function() { alert(i); };
};

for (var i=0; i&lt;5; i++) {
    $('&lt;p&gt;hacer click&lt;/p&gt;').appendTo('body').click(createFunction(i));
}
</pre>
              </div>
            </div>
            <p>
              Las clausuras tambi&eacute;n pueden ser utilizadas para resolver problemas con la palabra clave <code>this</code>, la cual es &uacute;nica en cada alcance.
            </p>
            <div class="example">
              <p class="title">
                <b>Utilizar una clausura para acceder simult&aacute;neamente a instancias de objetos internos y externos.</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var outerObj = {
    myName : 'externo',
    outerFunction : function () {

        // provee una referencia al mismo objeto outerObj para utilizar dentro de innerFunction
        var self = this;

        var innerObj = {
            myName : 'interno',
            innerFunction : function () {
                console.log(self.myName, this.myName); // registra 'externo interno'
            }
        };

        innerObj.innerFunction();

        console.log(this.myName); // registra 'externo'
    }
};

outerObj.outerFunction();
</pre>
              </div>
            </div>
            <p>
              Este mecanismo puede ser &uacute;til cuando trabaje con funciones de devoluci&oacute;n de llamadas (en ingl&eacute;s <em>callbacks</em>). Sin embargo, en estos casos, es preferible que utilice <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.bind</a> ya que evitar&aacute; cualquier sobrecarga asociada con el alcance (<em>scope</em>).
            </p>
          </div>
        </div> 
		</div>       <div title="Parte II. jQuery: Conceptos B&aacute;sicos">
		<h1 class="title">Parte II.& jQuery: Conceptos B&aacute;sicos</h1>
			  
		         <div id="capitulo-3" title="Conceptos B&aacute;sicos de jQuery" class="chapter">

			<h2 class="title">Conceptos B&aacute;sicos de jQuery</h2>
				
          <div title="$(document).ready()" class="section">
            <h2>
              $(document).ready()
            </h2>
            <p>
              No es posible interactuar de forma segura con el contenido de una p&aacute;gina hasta que el documento no se encuentre preparado para su manipulaci&oacute;n. jQuery permite detectar dicho estado a trav&eacute;s de la declaraci&oacute;n <code>$(document).ready()</code> de forma tal que el bloque se ejecutar&aacute; s&oacute;lo una vez que la p&aacute;gina este disponible.
            </p>
            <div class="example">
              <p class="title">
                <b>El bloque $(document).ready()</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$(document).ready(function() {
    console.log('el documento est&aacute; preparado');
});
</pre>
              </div>
            </div>
            <p>
              Existe una forma abreviada para <code>$(document).ready()</code> la cual podr&aacute; encontrar algunas veces; sin embargo, es recomendable no utilizarla en caso que este escribiendo c&oacute;digo para gente que no conoce jQuery.
            </p>
            <div class="example">
              <p class="title">
                <b>Forma abreviada para $(document).ready()</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$(function() {
    console.log('el documento est&aacute; preparado');
});
</pre>
              </div>
            </div>
            <p>
			  Adem&aacute;s es posible pasarle a <code>$(document).ready()</code> una funci&oacute;n nombrada en lugar de una an&oacute;nima:
            </p>
            <div class="example">
              <p class="title">
                <b>Pasar una funci&oacute;n nombrada en lugar de una funci&oacute;n an&oacute;nima</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
function readyFn() {
    // c&oacute;digo a ejecutar cuando el documento este listo
}


$(document).ready(readyFn);
</pre>
              </div>
            </div>
          </div>
          <h2>
            Selecci&oacute;n de Elementos
          </h2>
          <p>
			El concepto m&aacute;s b&aacute;sico de jQuery es el de "seleccionar algunos elementos y realizar acciones con ellos". La biblioteca soporta gran parte de los selectores CSS3 y varios m&aacute;s no estandarizados. En <a href="http://api.jquery.com/category/selectors/">http://api.jquery.com/category/selectors/</a> se puede encontrar una completa referencia sobre los selectores de la biblioteca.
          </p>
          <p>
            A continuaci&oacute;n se muestran algunas t&eacute;cnicas comunes para la selecci&oacute;n de elementos:
          </p>
          <div class="example">
            <p class="title">
              <b>Selecci&oacute;n de elementos en base a su ID</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('#myId'); // notar que los IDs deben ser &uacute;nicos por p&aacute;gina
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Selecci&oacute;n de elementos en base al nombre de clase</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('div.myClass'); // si se especifica el tipo de elemento, se mejora el rendimiento de la selecci&oacute;n
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Selecci&oacute;n de elementos por su atributo</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('input[name=first_name]'); // tenga cuidado, que puede ser muy lento
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Selecci&oacute;n de elementos en forma de selector CSS</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('#contents ul.people li');
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Pseudo-selectores</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('a.external:first');  // selecciona el primer elemento &lt;a&gt; con la clase 'external'
$('tr:odd');            // selecciona todos los elementos &lt;tr&gt; impares de una tabla
$('#myForm :input');    // selecciona todos los elementos del tipo input dentro del formulario #myForm
$('div:visible');       // selecciona todos los divs visibles
$('div:gt(2)');         // selecciona todos los divs excepto los tres primeros
$('div:animated');      // selecciona todos los divs actualmente animados
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
			Cuando se utilizan los pseudo-selectores <code>:visible</code> y <code>:hidden</code>, jQuery comprueba la visibilidad actual del elemento pero no si &eacute;ste posee asignados los estilos CSS <code>visibility</code> o <code>display</code> — en otras palabras, verifica si <em>el alto y ancho f&iacute;sico del elemento</em> es mayor a cero. Sin embargo, esta comprobaci&oacute;n no funciona con los elementos <code>&lt;tr&gt;</code>; en este caso, jQuery comprueba si se est&aacute; aplicando el estilo <code>display</code> y va a considerar al elemento como oculto si posee asignado el valor <code>none</code>. Adem&aacute;s, los elementos que a&uacute;n no fueron a&ntilde;adidos al DOM ser&aacute;n tratados como ocultos, incluso si tienen aplicados estilos indicando que deben ser visibles (En la secci&oacute;n Manipulaci&oacute;n de este manual, se explica como crear y a&ntilde;adir elementos al DOM)
          </p>
          <p>
			Como referencia, este es el fragmento de c&oacute;digo que utiliza jQuery para determinar cuando un elemento es visible o no. Se incorporaron los comentarios para que quede m&aacute;s claro su entendimiento:
          </p>
          <pre class="brush: js">
jQuery.expr.filters.hidden = function( elem ) {
    var width = elem.offsetWidth, height = elem.offsetHeight,
        skip = elem.nodeName.toLowerCase() === "tr";

    // ¿el elemento posee alto 0, ancho 0 y no es un &lt;tr&gt;?
    return width === 0 &amp;&amp; height === 0 &amp;&amp; !skip ?

        // entonces debe estar oculto (hidden)
        true :

        // pero si posee ancho y alto
		// y no es un &lt;tr&gt;
        width &gt; 0 &amp;&amp; height &gt; 0 &amp;&amp; !skip ?

            // entonces debe estar visible
            false :

            // si nos encontramos aqu&iacute;, es porque el elemento posee ancho
            // y alto, pero adem&aacute;s es un &lt;tr&gt;,
            // entonces se verifica el valor del estilo display aplicado a trav&eacute;s de CSS
            // para decidir si est&aacute; oculto o no
            jQuery.curCSS(elem, "display") === "none";
};

jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
};
</pre>
          </div>
          <div title="Elecci&oacute;n de Selectores" class="sidebar">
            <p class="title">
              <b>Elecci&oacute;n de Selectores</b>
            </p>
            <p>
              La elecci&oacute;n de buenos selectores es un punto importante cuando se desea mejorar el rendimiento del c&oacute;digo. Una peque&ntilde;a especificidad — por ejemplo, incluir el tipo de elemento (como <code>div</code>) cuando se realiza una selecci&oacute;n por el nombre de clase — puede ayudar bastante. Por eso, es recomendable darle algunas "pistas" a jQuery sobre en que lugar del documento puede encontrar lo que desea seleccionar. Por otro lado, demasiada especificidad puede ser perjudicial. Un selector como <code>#miTabla thead tr th.especial</code> es un exceso, lo mejor ser&iacute;a utilizar <code>#miTabla th.especial</code>.
            </p>
            <p>
              jQuery ofrece muchos selectores basados en atributos, que permiten realizar selecciones basadas en el contenido de los atributos utilizando simplificaciones de expresiones regulares.
            </p>
            <pre class="brush: js">
// encontrar todos los &lt;a&gt; cuyo atributo rel terminan en "thinger"
$("a[rel$='thinger']");
</pre>
            <p>
              Estos tipos de selectores pueden resultar &uacute;tiles pero tambi&eacute;n ser muy lentos. Cuando sea posible, es recomendable realizar la selecci&oacute;n utilizando IDs, nombres de clases y nombres de etiquetas.
            </p>
            <p>
              Si desea conocer m&aacute;s sobre este asunto, <a href="http://paulirish.com/perf">Paul Irish realiz&oacute; una gran presentaci&oacute;n sobre mejoras de rendimiento en JavaScript</a> (en ingles), la cual posee varias diapositivas centradas en selectores.
            </p>
          </div>
          <div title="Comprobar Selecciones" class="section">
              <h3>
                Comprobar Selecciones
              </h3>
            <p>
              Una vez realizada la selecci&oacute;n de los elementos, querr&aacute; conocer si dicha selecci&oacute;n entreg&oacute; alg&uacute;n resultado. Para ello, pueda que escriba algo as&iacute;:
            </p>
            <pre class="brush: js">
if ($('div.foo')) { ... }
</pre>
            <p>
			  Sin embargo esta forma no funcionar&aacute;. Cuando se realiza una selecci&oacute;n utilizando <code>$()</code>, siempre es devuelto un objeto, y si se lo eval&uacute;a, &eacute;ste siempre devolver&aacute; <code>true</code>. Incluso si la selecci&oacute;n no contiene ning&uacute;n elemento, el c&oacute;digo dentro del bloque <code>if</code> se ejecutar&aacute;.
            </p>
            <p>
			  En lugar de utilizar el c&oacute;digo mostrado, lo que se debe hacer es preguntar por la cantidad de elementos que posee la selecci&oacute;n que se ejecut&oacute;. Esto es posible realizarlo utilizando la propiedad JavaScript <code>length</code>. Si la respuesta es 0, la condici&oacute;n evaluar&aacute; falso, caso contrario (m&aacute;s de 0 elementos), la condici&oacute;n ser&aacute; verdadera.
            </p>
            <div class="example">
              <p class="title">
                <b>Evaluar si una selecci&oacute;n posee elementos</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
if ($('div.foo').length) { ... }
</pre>
              </div>
            </div>
          </div>
            <h3>
              Guardar Selecciones
            </h3>
          <p>
			Cada vez que se hace una selecci&oacute;n, una gran cantidad de c&oacute;digo es ejecutado. jQuery no guarda el resultado por si solo, por lo tanto, si va a realizar una selecci&oacute;n que luego se har&aacute; de nuevo, deber&aacute; salvar la selecci&oacute;n en una variable.
          </p>
          <div class="example">
            <p class="title">
              <b>Guardar selecciones en una variable</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var $divs = $('div');
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
			En el ejemplo “Guardar selecciones en una variable”, la variable comienza con el signo de d&oacute;lar. Contrariamente a otros lenguajes de programaci&oacute;n, en JavaScript este signo no posee ning&uacute;n significado especial &mdash; es solamente otro car&aacute;cter. Sin embargo aqu&iacute; se utilizar&aacute; para indicar que dicha variable posee un objeto jQuery. Esta pr&aacute;ctica &mdash; una especie de <a
            href="http://es.wikipedia.org/wiki/Notaci%C3%B3n_h%C3%BAngara"
           >Notaci&oacute;n H&uacute;ngara</a> &mdash; es solo una convenci&oacute;n y no es obligatoria.
          </p>
          </div>
          <p>
			Una vez que la selecci&oacute;n es guardada en la variable, se la puede utilizar en conjunto con los m&eacute;todos de jQuery y el resultado ser&aacute; igual que utilizando la selecci&oacute;n original.
          </p>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
			La selecci&oacute;n obtiene s&oacute;lo los elementos que est&aacute;n en la p&aacute;gina cuando se realiz&oacute; dicha acci&oacute;n. Si luego se a&ntilde;aden elementos al documento, ser&aacute; necesario repetir la selecci&oacute;n &oacute; a&ntilde;adir los elementos nuevos a la selecci&oacute;n guardada en la variable. En otras palabras, las selecciones guardadas no se actualizan "m&aacute;gicamente" cuando el DOM de modifica.
          </p>
          </div>
          <div title="Refining &amp; Filtering Selections" class="section">
              <h3>
                Refinamiento y Filtrado de Selecciones
              </h3>
            <p>
			  A veces, puede obtener una selecci&oacute;n que contiene m&aacute;s de lo que necesita; en este caso, es necesario refinar dicha selecci&oacute;n. jQuery ofrece varios m&eacute;todos para poder obtener exactamente lo que desea.
            </p>
            <div class="example">
              <p class="title">
                <b>Refinamiento de selecciones</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('div.foo').has('p');          // el elemento div.foo contiene elementos &lt;p&gt;
$('h1').not('.bar');            // el elemento h1 no posse la clase 'bar'
$('ul li').filter('.current');  // un item de una lista desordenada que posse la clase 'current'
$('ul li').first();             // el primer item de una lista desordenada
$('ul li').eq(5);               // el sexto item de una lista desordenada 
</pre>
              </div>
            </div>
          </div>
          <div title="Selecting Form Elements" class="section">
              <h3>
                Selecci&oacute;n de Elementos de un Formulario
              </h3>
            <p>
              jQuery ofrece varios pseudo-selectores que ayudan a encontrar elementos dentro de los formularios, &eacute;stos son especialmente &uacute;tiles ya que dependiendo de los estados de cada elemento o su tipo, puede ser dif&iacute;cil distinguirlos utilizando selectores CSS est&aacute;ndar.
            </p>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">:button</span>
                </dt>
                <dd>
                  <p>
                    Selecciona elementos <code>&lt;button&gt;</code> y con el atributo <code>type="button"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:checkbox</span>
                </dt>
                <dd>
                  <p>
                    Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="checkbox"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:checked</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> del tipo <code>checkbox</code> seleccionados
                  </p>
                </dd>
                <dt>
                  <span class="term">:disabled</span>
                </dt>
                <dd>
                  <p>
                    Selecciona elementos del formulario que est&aacute;n deshabitados
                  </p>
                </dd>
                <dt>
                  <span class="term">:enabled</span>
                </dt>
                <dd>
                  <p>
                    Selecciona elementos del formulario que est&aacute;n habilitados
                  </p>
                </dd>
                <dt>
                  <span class="term">:file</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="file"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:image</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="image"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:input</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> y <code>&lt;select&gt;</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:password</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="password"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:radio</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="radio"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:reset</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="reset"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:selected</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;options&gt;</code> que est&aacute;n seleccionados
                  </p>
                </dd>
                <dt>
                  <span class="term">:submit</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="submit"</code>
                  </p>
                </dd>
                <dt>
                  <span class="term">:text</span>
                </dt>
                <dd>
                  <p>
					Selecciona elementos <code>&lt;input&gt;</code> con el atributo <code>type="text"</code>
                  </p>
                </dd>
              </dl>
            </div>
            <div class="example">
              <p class="title">
                <b>Utilizando pseudo-selectores en elementos de formularios</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myForm :input'); // obtiene todos los elementos inputs dentro del formulario #myForm
</pre>
              </div>
            </div>
          </div>
          <div title="Trabajar con Selecciones" class="section">
            <h2>
              Trabajar con Selecciones
            </h2>
            <p>
              Una vez realizada la selecci&oacute;n de los elementos, es posible utilizarlos en conjunto con diferentes m&eacute;todos. &eacute;stos, generalmente, son de dos tipos: obtenedores (en ingl&eacute;s <em>getters</em>) y establecedores (en ingl&eacute;s <em>setters</em>). Los m&eacute;todos obtenedores devuelven una propiedad del elemento seleccionado; mientras que los m&eacute;todos establecedores fijan una propiedad a todos los elementos seleccionados.
            </p>
              <h3>
                Encadenamiento
              </h3>
            <p>
              Si en una selecci&oacute;n se realiza una llamada a un m&eacute;todo, y &eacute;ste devuelve un objeto jQuery, es posible seguir un "encadenado" de m&eacute;todos en el objeto.
            </p>
            <div class="example">
              <p class="title">
                <b>Encadenamiento</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#content').find('h3').eq(2).html('nuevo texto para el tercer elemento h3');
</pre>
              </div>
            </div>
            <p>
              Por otro lado, si se est&aacute; escribiendo un encadenamiento de m&eacute;todos que incluyen muchos pasos, es posible escribirlos l&iacute;nea por l&iacute;nea, haciendo que el c&oacute;digo luzca m&aacute;s agradable para leer.
            </p>
            <div class="example">
              <p class="title">
                <b>Formateo de c&oacute;digo encadenado</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#content')
    .find('h3')
    .eq(2)
    .html('nuevo texto para el tercer elemento h3');
</pre>
              </div>
            </div>
            <p>
              Si desea volver a la selecci&oacute;n original en el medio del encadenado, jQuery ofrece el m&eacute;todo <code>$.fn.end</code> para poder hacerlo.
            </p>
            <div class="example">
              <p class="title">
                <b>Restablecer la selecci&oacute;n original utilizando el m&eacute;todo <code>$.fn.end</code></b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#content')
    .find('h3')
    .eq(2)
        .html('nuevo texto para el tercer elemento h3')
    .end() // reestablece la selecci&oacute;n a todos los elementos h3 en #content
    .eq(0)
        .html('nuevo texto para el primer elemento h3');
</pre>
              </div>
            </div>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              El encadenamiento es muy poderoso y es una caracter&iacute;stica que muchas bibliotecas JavaScript han adoptado desde que jQuery se hizo popular. Sin embargo, debe ser utilizado con cuidado. Un encadenamiento de m&eacute;todos extensivo pueden hacer un c&oacute;digo extremadamente dif&iacute;cil de modificar y depurar. No existe una regla que indique que tan largo o corto debe ser el encadenado &mdash; pero es recomendable que tenga en cuenta este consejo.
            </p>
            </div>
            <div title="Obtenedores (Getters) & Establecedores (Setters)" class="section">
                <h3>
                  Obtenedores (Getters) & Establecedores (Setters)
                </h3>
              <p>
                jQuery "sobrecarga" sus m&eacute;todos, en otras palabras, el m&eacute;todo para establecer un valor posee el mismo nombre que el m&eacute;todo para obtener un valor. Cuando un m&eacute;todo es utilizado para establecer un valor, es llamado m&eacute;todo establecedor (en ingl&eacute;s <em>setter</em>). En cambio, cuando un m&eacute;todo es utilizado para obtener (o leer) un valor, es llamado obtenedor (en ingl&eacute;s <em>getter</em>).
              </p>
              <div class="example">
                <p class="title">
                  <b>El m&eacute;todo <code>$.fn.html</code> utilizado como establecedor</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('h1').html('hello world');
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>El m&eacute;todo html utilizado como obtenedor</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('h1').html();
</pre>
                </div>
              </div>
              <p>
                Los m&eacute;todos establecedores devuelven un objeto jQuery, permitiendo continuar con la llamada de m&aacute;s m&eacute;todos en la misma selecci&oacute;n, mientras que los m&eacute;todos obtenedores devuelven el valor por el cual se consult&oacute;, pero no permiten seguir llamando a m&aacute;s m&eacute;todos en dicho valor.
              </p>
            </div>
          </div>
          <h2>
            CSS, Estilos, & Dimensiones
          </h2>
          <p>
            jQuery incluye una manera &uacute;til de obtener y establecer propiedades CSS a los elementos.
          </p>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Las propiedades CSS que incluyen como separador un gui&oacute;n del medio, en JavaScript deben ser transformadas a su estilo <em class="firstterm">CamelCase</em>. Por ejemplo, cuando se la utiliza como propiedad de un m&eacute;todo, el estilo CSS <code>font-size</code> deber&aacute; ser expresado como <code>fontSize</code>. Sin embargo, esta regla no es aplicada cuando se pasa el nombre de la propiedad CSS al m&eacute;todo <code>$.fn.css</code> &mdash; en este caso, los dos formatos (en <em class="firstterm">CamelCase</em> &oacute; con el gui&oacute;n del medio) funcionar&aacute;n.
          </p>
          </div>
          <div class="example">
            <p class="title">
              <b>Obtener propiedades CSS</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('h1').css('fontSize'); // devuelve una cadena de caracteres como "19px"
$('h1').css('font-size'); // tambi&eacute;n funciona
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Establecer propiedades CSS</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('h1').css('fontSize', '100px'); // establece una propiedad individual CSS
$('h1').css({ 'fontSize' : '100px', 'color' : 'red' }); // establece m&uacute;ltiples propiedades CSS
</pre>
            </div>
          </div>
          <p class="remark">
            <i><span class="remark">Notar que el estilo del argumento utilizado en la segunda l&iacute;nea del ejemplo &mdash; es un objeto que contiene m&uacute;ltiples propiedades. Esta es una forma com&uacute;n de pasar m&uacute;ltiples argumentos a una funci&oacute;n, y muchos m&eacute;todos establecedores de la biblioteca aceptan objetos para fijar varias propiedades de una sola vez.</span></i>
          </p>
          <div title="Utilizar Clases para Aplicar Estilos CSS" class="section">
              <h3>
                Utilizar Clases para Aplicar Estilos CSS
              </h3>
            <p>
              Para obtener valores de los estilos aplicados a un elemento, el m&eacute;todo <code>$.fn.css</code> es muy &uacute;til, sin embargo, su utilizaci&oacute;n como m&eacute;todo establecedor se debe evitar (ya que, para aplicar estilos a un elemento, se puede hacer directamente desde CSS). En su lugar, lo ideal, es escribir reglas CSS que se apliquen a clases que describan los diferentes estados visuales de los elementos y luego cambiar la clase del elemento para aplicar el estilo que se desea mostrar.
            </p>
            <div class="example">
              <p class="title">
                <b>Trabajar con clases</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var $h1 = $('h1');

$h1.addClass('big');
$h1.removeClass('big');
$h1.toggleClass('big');

if ($h1.hasClass('big')) { ... }
</pre>
              </div>
            </div>
            <p>
              Las clases tambi&eacute;n pueden ser &uacute;tiles para guardar informaci&oacute;n del estado de un elemento, por ejemplo, para indicar que un elemento fue seleccionado.
            </p>
          </div>
          <div title="Dimensiones" class="section">
              <h3>
                Dimensiones
              </h3>
            <p>
              jQuery ofrece una variedad de m&eacute;todos para obtener y modificar valores de dimensiones y posici&oacute;n de un elemento.
            </p>
            <p>
              El c&oacute;digo mostrado en el ejemplo "M&eacute;todos b&aacute;sicos sobre Dimensiones" es solo un breve resumen de las funcionalidades relaciones a dimensiones en jQuery; para un completo detalle puede consultar <a href="http://api.jquery.com/category/dimensions/">http://api.jquery.com/category/dimensions/</a>.
            </p>
            <div class="example">
              <p class="title">
                <b>M&eacute;todos b&aacute;sicos sobre Dimensiones</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('h1').width('50px');   // establece el ancho de todos los elementos H1
$('h1').width();         // obtiene el ancho del primer elemento H1

$('h1').height('50px');  // establece el alto de todos los elementos H1
$('h1').height();        // obtiene el alto del primer elemento H1

$('h1').position();      // devuelve un objeto conteniendo informaci&oacute;n sobre la posici&oacute;n
                         // del primer elemento relativo al
                         // "offset" (posici&oacute;n) de su elemento padre
</pre>
              </div>
            </div>
          </div>
          <div title="Atributos" class="section">
            <h2>
              Atributos
            </h2>
            <p>
              Los atributos de los elementos HTML que conforman una aplicaci&oacute;n pueden contener informaci&oacute;n &uacute;til, por eso es importante poder establecer y obtener esa informaci&oacute;n.
            </p>
            <p>
              El m&eacute;todo <code>$.fn.attr</code> act&uacute;a tanto como m&eacute;todo establecedor como obtenedor. Adem&aacute;s, al igual que el m&eacute;todo <code>$.fn.css</code>, cuando se lo utiliza como m&eacute;todo establecedor, puede aceptar un conjunto de palabra clave-valor &oacute; un objeto conteniendo m&aacute;s conjuntos.
            </p>
            <div class="example">
              <p class="title">
                <b>Establecer atributos</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('a').attr('href', 'allMyHrefsAreTheSameNow.html');
$('a').attr({
    'title' : 'all titles are the same too',
    'href' : 'somethingNew.html'
});
</pre>
              </div>
            </div>
            <p class="remark">
              <i><span class="remark">En el ejemplo, el objeto pasado como argumento est&aacute; escrito en varias l&iacute;neas. Como se explic&oacute; anteriormente, los espacios en blanco no importan en JavaScript, por lo cual, es libre de utilizarlos para hacer el c&oacute;digo m&aacute;s legible. En entornos de producci&oacute;n, se pueden utilizar herramientas de minificaci&oacute;n, los cuales quitan los espacios en blanco (entre otras cosas) y comprimen el archivo final.</span></i>
            </p>
            <div class="example">
              <p class="title">
                <b>Obtener atributos</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('a').attr('href');  // devuelve el atributo href perteneciente al primer elemento &lt;a&gt; del documento
</pre>
              </div>
            </div>
          </div>
          <h2>
            Recorrer el DOM
          </h2>
          <p>
            Una vez obtenida la selecci&oacute;n, es posible encontrar otros elementos utilizando a la misma selecci&oacute;n.
          </p>
          <p>
            En <a href="http://api.jquery.com/category/traversing/">http://api.jquery.com/category/traversing/</a> puede encontrar una completa documentaci&oacute;n sobre los m&eacute;todos de recorrido de DOM (en ingl&eacute;s <em>traversing</em>) que posee jQuery.
          </p>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Debe ser cuidadoso en recorrer largas distancias en un documento &mdash; recorridos complejos obligan que la estructura del documento sea siempre la misma, algo que es dif&iacute;cil de garantizar. Uno -o dos- pasos para el recorrido esta bien, pero generalmente hay que evitar atravesar desde un contenedor a otro.
          </p>
          </div>
          <div class="example">
            <p class="title">
              <b>Moverse a trav&eacute;s del DOM utilizando m&eacute;todos de recorrido</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('h1').next('p');                            // seleccionar el inmediato y pr&oacute;ximo elemento &lt;p&gt; con respecto a H1
$('div:visible').parent();                    // seleccionar el elemento contenedor a un div visible
$('input[name=first_name]').closest('form');  // seleccionar el elemento &lt;form&gt; m&aacute;s cercano a un input
$('#myList').children();                      // seleccionar todos los elementos hijos de #myList
$('li.selected').siblings();                  // seleccionar todos los items hermanos del elemento &lt;li&gt;
</pre>
            </div>
          </div>
          <p>
            Tambi&eacute;n es posible interactuar con la selecci&oacute;n utilizando el m&eacute;todo <code>$.fn.each</code>. Dicho m&eacute;todo interact&uacute;a con todos los elementos obtenidos en la selecci&oacute;n y ejecuta una funci&oacute;n por cada uno. La funci&oacute;n recibe como argumento el &iacute;ndice del elemento actual y al mismo elemento. De forma predeterminada, dentro de la funci&oacute;n, se puede hacer referencia al elemento DOM a trav&eacute;s de la declaraci&oacute;n <code>this</code>.
          </p>
          <div class="example">
            <p class="title">
              <b>Interactuar en una selecci&oacute;n</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('#myList li').each(function(idx, el) {
    console.log(
        'El elemento ' + idx +
        'contiene el siguiente HTML: ' +
        $(el).html()
    );
});
</pre>
            </div>
          </div>
          <div title="Manipulaci&oacute;n de Elementos" class="section">
            <h2>
              Manipulaci&oacute;n de Elementos
            </h2>
            <p>
              Una vez realizada la selecci&oacute;n de los elementos que desea utilizar, "la diversi&oacute;n comienza". Es posible cambiar, mover, remover y duplicar elementos. Tambi&eacute;n crear nuevos a trav&eacute;s de una sintaxis simple.
            </p>
            <p>
              La documentaci&oacute;n completa sobre los m&eacute;todos de manipulaci&oacute;n puede encontrarla en <a href="http://api.jquery.com/category/manipulation/">http://api.jquery.com/category/manipulation/</a>.
            </p>
              <h3>
                Obtener y Establecer Informaci&oacute;n en Elementos
              </h3>
            <p>
              Existen muchas formas por las cuales de puede modificar un elemento. Entre las tareas m&aacute;s comunes est&aacute;n las de cambiar el HTML interno o alg&uacute;n atributo del mismo. Para este tipo de tareas, jQuery ofrece m&eacute;todos simples, funcionales en todos los navegadores modernos. Incluso es posible obtener informaci&oacute;n sobre los elementos utilizando los mismos m&eacute;todos pero en su forma de m&eacute;todo obtenedor.
            </p>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              Realizar cambios en los elementos, es un trabajo trivial, pero hay debe recordar que el cambio afectar&aacute; a <em>todos</em> los elementos en la selecci&oacute;n, por lo que, si desea modificar un s&oacute;lo elemento, tiene que estar seguro de especificarlo en la selecci&oacute;n antes de llamar al m&eacute;todo establecedor.
            </p>
            </div>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              Cuando los m&eacute;todos act&uacute;an como obtenedores, por lo general, solamente trabajan con el primer elemento de la selecci&oacute;n. Adem&aacute;s no devuelven un objeto jQuery, por lo cual no es posible encadenar m&aacute;s m&eacute;todos en el mismo. Una excepci&oacute;n es el m&eacute;todo <code>$.fn.text</code>, el cual permite obtener el texto de los elementos de la selecci&oacute;n.
            </p>
            </div>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">$.fn.html</span>
                </dt>
                <dd>
                  <p>
                    Obtiene o establece el contenido HTML de un elemento.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.text</span>
                </dt>
                <dd>
                  <p>
                    Obtiene o establece el contenido en texto del elemento; en caso se pasarle como argumento c&oacute;digo HTML, este es despojado.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.attr</span>
                </dt>
                <dd>
                  <p>
                    Obtiene o establece el valor de un determinado atributo.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.width</span>
                </dt>
                <dd>
                  <p>
                    Obtiene o establece el ancho en pixeles del primer elemento de la selecci&oacute;n como un entero.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.height</span>
                </dt>
                <dd>
                  <p>
                    Obtiene o establece el alto en pixeles del primer elemento de la selecci&oacute;n como un entero.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.position</span>
                </dt>
                <dd>
                  <p>
                    Obtiene un objeto con informaci&oacute;n sobre la posici&oacute;n del primer elemento de la selecci&oacute;n, relativo al primer elemento padre posicionado. <em>Este m&eacute;todo es solo obtenedor.</em>
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.val</span>
                </dt>
                <dd>
                  <p>
                    Obtiene o establece el valor (<em>value</em>) en elementos de formularios.
                  </p>
                </dd>
              </dl>
            </div>
            <div class="example">
              <p class="title">
                <b>Cambiar el HTML de un elemento</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myDiv p:first')
    .html('Nuevo &lt;strong&gt;primer&lt;/strong&gt; p&aacute;rrafo');
</pre>
              </div>
            </div>
            <div title="Mover, Copiar y Remover Elementos" class="section">
                <h3>
                  Mover, Copiar y Remover Elementos
                </h3>
              <p>
                Existen varias maneras para mover elementos a trav&eacute;s del DOM; las cuales se pueden separar en dos enfoques:
              </p>
              <ul>
                <li>
                  <p>
                    Querer colocar el/los elementos seleccionados de forma relativa a otro elemento
                  </p>
                </li>
                <li>
                  <p>
                    Querer colocar un elemento relativo a el/los elementos seleccionados.
                  </p>
                </li>
              </ul>
              <p>
                Por ejemplo, jQuery provee los m&eacute;todos <code>$.fn.insertAfter</code> y <code>$.fn.after</code>. El m&eacute;todo <code>$.fn.insertAfter</code> coloca a el/los elementos seleccionados despu&eacute;s del elemento que se haya pasado como argumento; mientras que el m&eacute;todo <code>$.fn.after</code> coloca al elemento pasado como argumento despu&eacute;s del elemento seleccionado. Otros m&eacute;todos tambi&eacute;n siguen este patr&oacute;n: <code>$.fn.insertBefore</code> y <code>$.fn.before</code>; <code>$.fn.appendTo</code> y <code>$.fn.append</code>; y <code>$.fn.prependTo</code> y <code>$.fn.prepend</code>.
              </p>
              <p>
                La utilizaci&oacute;n de uno u otro m&eacute;todo depender&aacute; de los elementos que tenga seleccionados y el tipo de referencia que se quiera guardar con respecto al elemento que se esta moviendo.
              </p>
              <div class="example">
                <p class="title">
                  <b>Mover elementos utilizando diferentes enfoques</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
// hacer que el primer item de la lista sea el &uacute;ltimo
var $li = $('#myList li:first').appendTo('#myList');

// otro enfoque para el mismo problema
$('#myList').append($('#myList li:first'));

// debe tener en cuenta que no hay forma de acceder a la
// lista de items que se ha movido, ya que devuelve
// la lista en s&iacute;
</pre>
                </div>
              </div>
                <h4>
                  Clonar Elementos
                </h4>
              <p>
                Cuando se utiliza un m&eacute;todo como <code>$.fn.appendTo</code>, lo que se est&aacute; haciendo es mover al elemento; pero a veces en lugar de eso, se necesita mover un duplicado del mismo elemento. En este caso, es posible utilizar el m&eacute;todo <code>$.fn.clone</code>.
              </p>
              <div class="example">
                <p class="title">
                  <b>Obtener una copia del elemento</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
// copiar el primer elemento de la lista y moverlo al final de la misma
$('#myList li:first').clone().appendTo('#myList');
</pre>
                </div>
              </div>
              <div class="note">
              <h3>
                Nota
              </h3>
              <p>
                Si se necesita copiar informaci&oacute;n y eventos relacionados al elemento, se debe pasar <code>true</code> como argumento de <code>$.fn.clone</code>.
              </p>
              </div>
                <h4>
                  Remover elementos
                </h4>
              <p>
                Existen dos formas de remover elementos de una p&aacute;gina: Utilizando <code>$.fn.remove</code> &oacute; <code>$.fn.detach</code>. Cuando desee remover de forma permanente al elemento, utilize el m&eacute;todo <code>$.fn.remove</code>. Por otro lado, el m&eacute;todo $.fn.detach tambi&eacute;n remueve el elemento, pero mantiene la informaci&oacute;n y eventos asociados al mismo, siendo &uacute;til en el caso que necesite reinsertar el elemento en el documento.
              </p>
              <div class="note">
              <h3>
                Nota
              </h3>
              <p>
                El m&eacute;todo <code>$.fn.detach</code> es muy &uacute;til cuando se esta manipulando de forma severa un elemento, ya que es posible eliminar al elemento, trabajarlo en el c&oacute;digo y luego restaurarlo en la p&aacute;gina nuevamente. Esta forma tiene como beneficio no tocar el DOM mientras se est&aacute; modificando la informaci&oacute;n y eventos del elemento.
              </p>
              </div>
              <p>
                Por otro lado, si se desea mantener al elemento pero se necesita eliminar su contenido, es posible utiliza el m&eacute;todo <code>$.fn.empty</code>, el cual "vaciar&aacute;" el contenido HTML del elemento.
              </p>
            </div>
              <h3>
                Crear Nuevos Elementos
              </h3>
            <p>
              jQuery provee una forma f&aacute;cil y elegante para crear nuevos elementos a trav&eacute;s del mismo m&eacute;todo <code>$()</code> que se utiliza para realizar selecciones.
            </p>
            <div class="example">
              <p class="title">
                <b>Crear nuevos elementos</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('&lt;p&gt;Un nuevo p&aacute;rrafo&lt;/p&gt;');
$('&lt;li class="new"&gt;nuevo item de la lista&lt;/li&gt;');
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Crear un nuevo elemento con atributos utilizando un objeto</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('&lt;a/&gt;', {
    html : 'Un &lt;strong&gt;nuevo&lt;/strong&gt; enlace',
    'class' : 'new',
    href : 'foo.html'
});
</pre>
              </div>
            </div>
            <p class="remark">
              <i><span class="remark">Note que en el objeto que se pasa como argumento, la propiedad class est&aacute; entre comillas, mientras que la propiedad href y html no lo est&aacute;n. Por lo general, los nombres de propiedades no deben estar entre comillas, excepto en el caso que se utilice como nombre una palabra reservada (como es el caso de class).</span></i>
            </p>
            <p>
              Cuando se crea un elemento, &eacute;ste no es a&ntilde;adido inmediatamente a la p&aacute;gina, sino que se debe hacerlo en conjunto con un m&eacute;todo.
            </p>
            <div class="example">
              <p class="title">
                <b>Crear un nuevo elemento en la p&aacute;gina</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var $myNewElement = $('&lt;p&gt;Nuevo elemento&lt;/p&gt;');
$myNewElement.appendTo('#content');

$myNewElement.insertAfter('ul:last'); // eliminar&aacute; al elemento &lt;p&gt; existente en #content
$('ul').last().after($myNewElement.clone());  // clonar al elemento &lt;p&gt; para tener las dos versiones
</pre>
              </div>
            </div>
            <p class="remark">
              <i><span class="remark">Estrictamente hablando, no es necesario guardar al elemento creado en una variable &mdash; es posible llamar al m&eacute;todo para a&ntilde;adir el elemento directamente despu&eacute;s de $(). Sin embargo, la mayor&iacute;a de las veces se desear&aacute; hacer referencia al elemento a&ntilde;adido, por lo cual, si se guarda en una variable no es necesario seleccionarlo despu&eacute;s.</span></i>
            </p>
            <div class="example">
              <p class="title">
                <b>Crear y a&ntilde;adir al mismo tiempo un elemento a la p&aacute;gina</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('ul').append('&lt;li&gt;item de la lista&lt;/li&gt;');
</pre>
              </div>
            </div>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              La sintaxis para a&ntilde;adir nuevos elementos a la p&aacute;gina es muy f&aacute;cil de utilizar, pero es tentador olvidar que hay un costo enorme de rendimiento al agregar elementos al DOM de forma repetida. Si esta a&ntilde;adiendo muchos elementos al mismo contenedor, en lugar de a&ntilde;adir cada elemento uno por vez, lo mejor es concatenar todo el HTML en una &uacute;nica cadena de caracteres para luego anexarla al contenedor. Una posible soluci&oacute;n es utilizar un arreglo que posea todos los elementos, luego reunirlos utilizando <code>join</code> y finalmente anexarla.
            </p>
            <pre class="brush: js">
var myItems = [], $myList = $('#myList');

for (var i=0; i&lt;100; i++) {
    myItems.push('&lt;li&gt;item ' + i + '&lt;/li&gt;');
}

$myList.append(myItems.join(''));
</pre>
            </div>
            <div title="Manipulating Attributes" class="section">
                <h3>
                  Manipulaci&oacute;n de Atributos
                </h3>
              <p>
                Las capacidades para la manipulaci&oacute;n de atributos que ofrece la biblioteca son extensos. La realizaci&oacute;n de cambios b&aacute;sicos son simples, sin embargo el m&eacute;todo <code>$.fn.attr</code> permite manipulaciones m&aacute;s complejas.
              </p>
              <div class="example">
                <p class="title">
                  <b>Manipular un simple atributo</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('#myDiv a:first').attr('href', 'newDestination.html');
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Manipular m&uacute;ltiples atributos</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('#myDiv a:first').attr({
    href : 'newDestination.html',
    rel : 'super-special'
});
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Utilizar una funci&oacute;n para determinar el valor del nuevo atributo</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('#myDiv a:first').attr({
    rel : 'super-special',
    href : function(idx, href) {
        return '/new/' + href;
    }
});

$('#myDiv a:first').attr('href', function(idx, href) {
    return '/new/' + href;
});
</pre>
                </div>
              </div>
            </div>
          </div>
          <div title="Ejercicios" class="section">
            <h2>
              Ejercicios
            </h2>
            <div title="Selecting" class="section">
                <h3>
                  Selecciones
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejercicio utilizando el archivo <code class="filename">/exercises/js/sandbox.js</code> &oacute; trabaje directamente con Firebug para cumplir los siguientes puntos:
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      Seleccionar todos los elementos div que poseen la clase "module".
                    </p>
                  </li>
                  <li>
                    <p>
                      Especificar tres selecciones que puedan seleccionar el tercer &iacute;tem de la lista desordenada #myList. ¿Cu&aacute;l es el mejor para utilizar? ¿Porqu&eacute;?
                    </p>
                  </li>
                  <li>
                    <p>
                      Seleccionar el elemento <code>label</code> del elemento <code>input</code> utilizando un selector de atributo.
                    </p>
                  </li>
                  <li>
                    <p>
                      Averiguar cuantos elementos en la p&aacute;gina est&aacute;n ocultos (ayuda: <code>.length</code>)
                    </p>
                  </li>
                  <li>
                    <p>
                      Averiguar cuantas im&aacute;genes en la p&aacute;gina poseen el atributo <code>alt</code>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Seleccionar todas las filas impares del cuerpo de la tabla.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
            <div title="Recorrer el DOM" class="section">
                <h3>
                  Recorrer el DOM
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejercicio utilizando el archivo <code class="filename">/exercises/js/sandbox.js</code> &oacute; trabaje directamente con Firebug para cumplir los siguientes puntos:
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      Seleccionar todas las im&aacute;genes en la p&aacute;gina; registrar en la consola el atributo <code>alt</code> de cada imagen.
                    </p>
                  </li>
                  <li>
                    <p>
                      Seleccionar el elemento <code>input</code>, luego dirigirse hacia el formulario y a&ntilde;adirle una clase al mismo.
                    </p>
                  </li>
                  <li>
                    <p>
                      Seleccionar el &iacute;tem que posee la clase "current" dentro de la lista #myList y remover dicha clase en el elemento; luego a&ntilde;adir la clase "current" al siguiente &iacute;tem de la lista.
                    </p>
                  </li>
                  <li>
                    <p>
                      Seleccionar el elemento <code>select</code> dentro de #specials; luego dirigirse hacia el bot&oacute;n <code>submit</code>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Seleccionar el primer &iacute;tem de la lista en el elemento #slideshow; a&ntilde;adirle la clase "current" al mismo y luego a&ntilde;adir la clase "disabled" a los elementos hermanos.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
            <div title="Manipulaci&oacute;n" class="section">
                <h3>
                  Manipulaci&oacute;n
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejercicio utilizando el archivo <code class="filename">/exercises/js/sandbox.js</code> &oacute; trabaje directamente con Firebug para cumplir los siguientes puntos:
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      A&ntilde;adir 5 nuevos &iacute;tems al final de la lista desordenada #myList. Ayuda:
                    </p>
                    <pre class="brush: js">
for (var i = 0; i&lt;5; i++) { ... }
</pre>
                  </li>
                  <li>
                    <p>
                      Remover los &iacute;tems impares de la lista.
                    </p>
                  </li>
                  <li>
                    <p>
                      A&ntilde;adir otro elemento <code>h2</code> y otro p&aacute;rrafo al &uacute;ltimo <code>div.module</code>.
                    </p>
                  </li>
                  <li>
                    <p>
                      A&ntilde;adir otra opci&oacute;n al elemento select; darle a la opci&oacute;n a&ntilde;adida el valor <em>"Wednesday"</em>.
                    </p>
                  </li>
                  <li>
                    <p>
                      A&ntilde;adir un nuevo <code>div.module</code> a la p&aacute;gina despu&eacute;s del &uacute;ltimo; luego a&ntilde;adir una copia de una de las im&aacute;genes existentes dentro del nuevo <code>div</code>.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
          </div>
        </div>        <div id="capitulo-4" title="El n&uacute;cleo de jQuery" class="chapter">
			<h2 class="title">El n&uacute;cleo de jQuery</h2>
          <div title="$ vs $()" class="section">
            <h2>
              <code>$</code> vs <code>$()</code>
            </h2>
            <p>
              Hasta ahora, se ha tratado completamente con m&eacute;todos que se llaman desde el objeto jQuery. Por ejemplo:
            </p>
            <pre class="brush: js">
$('h1').remove();
</pre>
            <p>
              Dichos m&eacute;todos son parte del espacio de nombres (en ingl&eacute;s <em>namespace</em>) <code>$.fn</code>, o del prototipo (en ingl&eacute;s <em>prototype</em>) de jQuery, y son considerados como m&eacute;todos del objeto jQuery.
            </p>
            <p>
              Sin embargo, existen m&eacute;todos que son parte del espacio de nombres de $ y se consideran como m&eacute;todos del n&uacute;cleo de jQuery.
            </p>
            <p>
              Estas distinciones pueden ser bastantes confusas para usuarios nuevos . Para evitar la confusi&oacute;n, debe recordar estos dos puntos:
            </p>
            <ul>
              <li>Los m&eacute;todos utilizados en selecciones se encuentran dentro del espacio de nombres <code>$.fn</code>, y autom&aacute;ticamente reciben y devuelven una selecci&oacute;n en s&iacute;.
              </li>
              <li>M&eacute;todos en el espacio de nombres <code>$</code> son generalmente m&eacute;todos para diferentes utilidades, no trabajan con selecciones, no se les pasa ning&uacute;n argumento y el valor que devuelven puede variar.
              </li>
            </ul>
            <p>
              Existen algunos casos en donde m&eacute;todos del objeto y del n&uacute;cleo poseen los mismos nombres, como sucede con <code>$.each</code> y <code>$.fn.each</code>. En estos casos, debe ser cuidadoso de leer bien la documentaci&oacute;n para saber que objeto utilizar correctamente.
            </p>
          </div>
          <div title="M&eacute;todos Utilitarios" class="section">
            <h2>
              M&eacute;todos Utilitarios
            </h2>
            <p>
              jQuery ofrece varios m&eacute;todos utilitarios dentro del espacio de nombres <code>$</code>. Estos m&eacute;todos son de gran ayuda para llevar a cabo tareas rutinarias de programaci&oacute;n. A continuaci&oacute;n se muestran algunos ejemplos, para una completa documentaci&oacute;n sobre ellos, visite <a href="http://api.jquery.com/category/utilities/">http://api.jquery.com/category/utilities/</a>.
            </p>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">$.trim</span>
                </dt>
                <dd>
                  <p>
                    Remueve los espacios en blanco del principio y final.
                  </p>
                  <pre class="brush: js">
$.trim('    varios espacios en blanco   ');
// devuelve 'varios espacios en blanco'
</pre>
                </dd>
                <dt>
                  <span class="term">$.each</span>
                </dt>
                <dd>
                  <p>
                    Interact&uacute;a en arreglos y objetos.
                  </p>
                  <pre class="brush: js">
$.each([ 'foo', 'bar', 'baz' ], function(idx, val) {
    console.log('elemento ' + idx + 'es ' + val);
});

$.each({ foo : 'bar', baz : 'bim' }, function(k, v) {
    console.log(k + ' : ' + v);
});
</pre>
                  <div class="note">
                  <h3>
                    Nota
                  </h3>
                  <p>
                    Como se dijo antes, existe un m&eacute;todo llamado <code>$.fn.each</code>, el cual interact&uacute;a en una selecci&oacute;n de elementos.
                  </p>
                  </div>
                </dd>
                <dt>
                  <span class="term">$.inArray</span>
                </dt>
                <dd>
                  <p>
                    Devuelve el &iacute;ndice de un valor en un arreglo, &oacute; -1 si el valor no se encuentra en el arreglo.
                  </p>
                  <pre class="brush: js">
var myArray = [ 1, 2, 3, 5 ];

if ($.inArray(4, myArray) !== -1) {
    console.log('valor encontrado');
}
</pre>
                </dd>
                <dt>
                  <span class="term">$.extend</span>
                </dt>
                <dd>
                  <p>
                    Cambia la propiedades del primer objeto utilizando las propiedades de los subsecuentes objetos.
                  </p>
                  <pre class="brush: js">
var firstObject = { foo : 'bar', a : 'b' };
var secondObject = { foo : 'baz' };

var newObject = $.extend(firstObject, secondObject);
console.log(firstObject.foo); // 'baz'
console.log(newObject.foo);   // 'baz'
</pre>
                  <p>
                    Si no se desea cambiar las propiedades de ninguno de los objetos que se utilizan en <code>$.extend</code>, se debe incluir un objeto vac&iacute;o como primer argumento.
                  </p>
                  <pre class="brush: js">
var firstObject = { foo : 'bar', a : 'b' };
var secondObject = { foo : 'baz' };

var newObject = $.extend({}, firstObject, secondObject);
console.log(firstObject.foo); // 'bar'
console.log(newObject.foo);   // 'baz'
</pre>
                </dd>
                <dt>
                  <span class="term">$.proxy</span>
                </dt>
                <dd>
                  <p>
                    Devuelve una funci&oacute;n que siempre se ejecutar&aacute; en el alcance (<em>scope</em>) provisto — en otras palabras, establece el significado de <em>this</em> (incluido dentro de la funci&oacute;n) como el segundo argumento.
                  </p>
                  <pre class="brush: js">
var myFunction = function() { console.log(this); };
var myObject = { foo : 'bar' };

myFunction(); // devuelve el objeto window

var myProxyFunction = $.proxy(myFunction, myObject);
myProxyFunction(); // devuelve el objeto myObject
</pre>
                  <p>
                    Si se posee un objeto con m&eacute;todos, es posible pasar dicho objeto y el nombre de un m&eacute;todo para devolver una funci&oacute;n que siempre se ejecuta en el alcance de dicho objeto.
                  </p>
                  <pre class="brush: js">
var myObject = {
    myFn : function() {
        console.log(this);
    }
};

$('#foo').click(myObject.myFn); // registra el elemento DOM #foo
$('#foo').click($.proxy(myObject, 'myFn')); // registra myObject
</pre>
                </dd>
              </dl>
            </div>
          </div>
          <div title="Comprobaci&oacute;n de Tipos" class="section">
            <h2>
              Comprobaci&oacute;n de Tipos
            </h2>
            <p>
              Como se mencion&oacute; en el cap&iacute;tulo "Conceptos B&aacute;sicos de JavaScript", jQuery ofrece varios m&eacute;todos &uacute;tiles para determinar el tipo de un valor espec&iacute;fico.
            </p>
            <div class="example">
              <p class="title">
                <b>Comprobar el tipo de un determinado valor</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var myValue = [1, 2, 3];

// Utilizar el operador typeof de JavaScript para comprobar tipos primitivos
typeof myValue == 'string'; // falso (false)
typeof myValue == 'number'; // falso (false)
typeof myValue == 'undefined'; // falso (false)
typeof myValue == 'boolean'; // falso (false)

// Utilizar el operador de igualdad estricta para comprobar valores nulos (null)
myValue === null; // falso (false)

// Utilizar los m&eacute;todos jQuery para comprobar tipos no primitivos
jQuery.isFunction(myValue); // falso (false)
jQuery.isPlainObject(myValue); // falso (false)
jQuery.isArray(myValue); // verdadero (true)
</pre>
              </div>
            </div>
          </div>
          <div title="El M&eacute;todo Data" class="section">
            <h2>
              El M&eacute;todo Data
            </h2>
            <p>
              A menudo encontrar&aacute; que existe informaci&oacute;n acerca de un elemento que necesita guardar. En JavaScript es posible hacerlo a&ntilde;adiendo propiedades al DOM del elemento, pero esta pr&aacute;ctica conlleva enfrentarse a p&eacute;rdidas de memoria (en ingl&eacute;s <em>memory leaks</em>) en algunos navegadores. jQuery ofrece una manera sencilla para poder guardar informaci&oacute;n relacionada a un elemento, y la misma biblioteca se ocupa de manejar los problemas que pueden surgir por falta de memoria.
            </p>
            <div class="example">
              <p class="title">
                <b>Guardar y recuperar informaci&oacute;n relacionada a un elemento</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myDiv').data('keyName', { foo : 'bar' });
$('#myDiv').data('keyName'); // { foo : 'bar' }
</pre>
              </div>
            </div>
            <p>
              A trav&eacute;s del m&eacute;todo <code>$.fn.data</code> es posible guardar cualquier tipo de informaci&oacute;n sobre un elemento, y es dif&iacute;cil exagerar la importancia de este concepto cuando se est&aacute; desarrollando una aplicaci&oacute;n compleja.
            </p>
            <p>
              Por ejemplo, si desea establecer una relaci&oacute;n entre el &iacute;tem de una lista y el div que hay dentro de este &iacute;tem, es posible hacerlo cada vez que se interact&uacute;a con el &iacute;tem, pero una mejor soluci&oacute;n es hacerlo una sola vez, guardando un puntero al div utilizando el m&eacute;todo <code>$.fn.data</code>:
            </p>
            <div class="example">
              <p class="title">
                <b>Establecer una relaci&oacute;n entre elementos utilizando el m&eacute;todo <code>$.fn.data</code></b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myList li').each(function() {
    var $li = $(this), $div = $li.find('div.content');
    $li.data('contentDiv', $div);
});

// luego, no se debe volver a buscar al div;
// es posible leerlo desde la informaci&oacute;n asociada al item de la lista
var $firstLi = $('#myList li:first');
$firstLi.data('contentDiv').html('nuevo contenido');
</pre>
              </div>
            </div>
            <p>
              Adem&aacute;s es posible pasarle al m&eacute;todo un objeto conteniendo uno o m&aacute;s pares de conjuntos palabra clave-valor.
            </p>
          </div>
          <div title="Detecci&oacute;n de Navegadores y Caracter&iacute;sticas" class="section">
            <h2>
              Detecci&oacute;n de Navegadores y Caracter&iacute;sticas
            </h2>
            <p>
              M&aacute;s all&aacute; que jQuery elimine la mayor&iacute;a de las peculiaridades de JavaScript entre cada navegador, existen ocasiones en que se necesita ejecutar c&oacute;digo en un navegador espec&iacute;fico.
            </p>
            <p>
              Para este tipo de situaciones, jQuery ofrece el objeto <code>$.support</code> y <code>$.browser</code> (este &uacute;ltimo en desuso). Una completa documentaci&oacute;n sobre estos objetos puede encontrarla en <a href="http://api.jquery.com/jQuery.support/">http://api.jquery.com/jQuery.support/</a> y <a href="http://api.jquery.com/jQuery.browser/">http://api.jquery.com/jQuery.browser/</a>
            </p>
            <p>
              El objetivo de <code>$.support</code> es determinar qu&eacute; caracter&iacute;sticas soporta el navegador web.
            </p>
            <p>
              El objeto <code>$.browser</code> permite detectar el tipo de navegador y su versi&oacute;n. Dicho objeto est&aacute; en desuso (aunque en el corto plazo no est&aacute; planificada su eliminaci&oacute;n del n&uacute;cleo de la biblioteca) y se recomienda utilizar al objeto <code>$.support</code> para estos prop&oacute;sitos.
            </p>
          </div>
          <div title="Evitar Conflictos con Otras Bibliotecas JavaScript" class="section">
            <h2>
              Evitar Conflictos con Otras Bibliotecas JavaScript
            </h2>
            <p>
              Si esta utilizando jQuery en conjunto con otras bibliotecas JavaScript, las cuales tambi&eacute;n utilizan la variable <code>$</code>, pueden llegar a ocurrir una serie de errores. Para poder solucionarlos, es necesario poner a jQuery en su modo "no-conflicto". Esto se debe realizar inmediatamente despu&eacute;s que jQuery se cargue en la p&aacute;gina y antes del c&oacute;digo que se va a ejecutar.
            </p>
            <p>
              Cuando se pone a jQuery en modo "no-conflicto", la biblioteca ofrece la opci&oacute;n de asignar un nombre para reemplazar a la variable <code>$</code>.
            </p>
            <div class="example">
              <p class="title">
                <b>Poner a jQuery en modo no-conflicto</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
&lt;script src="prototype.js"&gt;&lt;/script&gt;             // la biblioteca prototype tambi&eacute;n utiliza $
&lt;script src="jquery.js"&gt;&lt;/script&gt;                // se carga jquery en la p&aacute;gina
&lt;script&gt;var $j = jQuery.noConflict();&lt;/script&gt;   // se inicializa el modo "no-conflicto"
</pre>
              </div>
            </div>
            <p>
              Tambi&eacute;n es posible seguir utilizando <code>$</code> conteniendo el c&oacute;digo en una funci&oacute;n an&oacute;nima autoejecutable. &Eacute;ste es un patr&oacute;n est&aacute;ndar para la creaci&oacute;n de extensiones para la biblioteca, ya que <code>$</code> queda encerrada dentro del alcance de la misma funci&oacute;n an&oacute;nima.
            </p>
            <div class="example">
              <p class="title">
                <b>Utilizar $ dentro de una funci&oacute;n an&oacute;nima autoejecutable</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
&lt;script src="prototype.js"&gt;&lt;/script&gt;
&lt;script src="jquery.js"&gt;&lt;/script&gt;
&lt;script&gt;
jQuery.noConflict();

(function($) {
   // el c&oacute;digo va aqu&iacute;, pudiendo utilizar $
})(jQuery);
&lt;/script&gt;
</pre>
              </div>
            </div>
          </div>
        </div>        <div id="capitulo-5" title="Eventos" class="chapter">
			<h2 class="title">Eventos</h2>
          <div title="Overview" class="section">
            <h2>
              Introducci&oacute;n
            </h2>
            <p>
              jQuery provee m&eacute;todos para asociar controladores de eventos (en ingl&eacute;s <em>event handlers</em>) a selectores. Cuando un evento ocurre, la funci&oacute;n provista es ejecutada.
            </p>
            <p>
              Dentro de la funci&oacute;n, la palabra clave this hace referencia al elemento en que el evento ocurre.
            </p>
            <p>
              Para m&aacute;s detalles sobre los eventos en jQuery, puede consultar <a href="http://api.jquery.com/category/events/">http://api.jquery.com/category/events/</a>.
            </p>
            <p>
              La funci&oacute;n del controlador de eventos puede recibir un objeto. Este objeto puede ser utilizado para determinar la naturaleza del evento o, por ejemplo, prevenir el comportamiento predeterminado de &eacute;ste.
            </p>
            <p>
              Para m&aacute;s detalles sobre el objeto del evento, visite <a href="http://api.jquery.com/category/events/event-object/">http://api.jquery.com/category/events/event-object/</a>.
            </p>
          </div>
          <div title="Vincular Eventos a Elementos" class="section">
            <h2>
              Vincular Eventos a Elementos
            </h2>
            <p>
              jQuery ofrece m&eacute;todos para la mayor&iacute;a de los eventos &mdash; entre ellos <code>$.fn.click</code>, <code
              class="code">$.fn.focus</code>, <code
              class="code">$.fn.blur</code>, <code
              class="code">$.fn.change</code>, etc. Estos &uacute;ltimos son formas reducidas del m&eacute;todo <code>$.fn.bind</code> de jQuery. El m&eacute;todo bind es &uacute;til para vincular (en ingl&eacute;s <em>binding</em>) la misma funci&oacute;n de controlador a m&uacute;ltiples eventos, para cuando se desea proveer informaci&oacute;n al controlador de evento, cuando se est&aacute; trabajando con eventos personalizados &oacute; cuando se desea pasar un objeto a m&uacute;ltiples eventos y controladores.
            </p>
            <div class="example">
              <p class="title">
                <b>Vincular un evento utilizando un m&eacute;todo reducido</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('p').click(function() {
    console.log('click');
});
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Vincular un evento utilizando el m&eacute;todo <code>$.fn.bind</code> method</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('p').bind('click', function() {
    console.log('click');
});
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Vincular un evento utilizando el m&eacute;todo <code>$.fn.bind</code> con informaci&oacute;n asociada</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('input').bind(
    'click change',  // es posible incular m&uacute;ltiples eventos al elemento
    { foo : 'bar' }, // se debe pasar la informaci&oacute;n asociada como argumento

    function(eventObject) {
        console.log(eventObject.type, eventObject.data);
        // registra el tipo de evento y la informaci&oacute;n asociada { foo : 'bar' }
    }
);
</pre>
              </div>
            </div>
            <div title="Vincular Eventos para Ejecutar una vez" class="section">
                <h3>
                  Vincular Eventos para Ejecutar una vez
                </h3>
              <p>
                A veces puede necesitar que un controlador particular se ejecute solo una vez &mdash; y despu&eacute;s de eso, necesite que ninguno m&aacute;s se ejecute, o que se ejecute otro diferente. Para este prop&oacute;sito jQuery provee el m&eacute;todo <code>$.fn.one</code>.
              </p>
              <div class="example">
                <p class="title">
                  <b>Cambiar controladores utilizando el m&eacute;todo <code>$.fn.one</code></b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('p').one('click', function() {
    console.log('Se clicke&oacute; al elemento por primera vez');
    $(this).click(function() { console.log('Se ha clickeado nuevamente'); });
});
</pre>
                </div>
              </div>
              <p>
                El m&eacute;todo <code>$.fn.one</code> es &uacute;til para situaciones en que necesita ejecutar cierto c&oacute;digo la primera vez que ocurre un evento en un elemento, pero no en los eventos sucesivos.
              </p>
            </div>
            <div title="Desvincular Eventos" class="section">
                <h3>
                  Desvincular Eventos
                </h3>
              <p>
                Para desvincular (en ingles <em>unbind</em>) un controlador de evento, puede utilizar el m&eacute;todo <code>$.fn.unbind</code> pas&aacute;ndole el tipo de evento a desconectar. Si se pas&oacute; como adjunto al evento una funci&oacute;n nombrada, es posible aislar la desconexi&oacute;n de dicha funci&oacute;n pas&aacute;ndola como segundo argumento.
              </p>
              <div class="example">
                <p class="title">
                  <b>Desvincular todos los controladores del evento click en una selecci&oacute;n</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('p').unbind('click');
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Desvincular un controlador particular del evento click</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var foo = function() { console.log('foo'); };
var bar = function() { console.log('bar'); };

$('p').bind('click', foo).bind('click', bar);
$('p').unbind('click', bar); // foo esta atado a&uacute;n al evento click
</pre>
                </div>
              </div>
            </div>
            <div title="Espacios de Nombres para Eventos" class="section">
                <h3>
                  Espacios de Nombres para Eventos
                </h3>
              <p>
                Cuando se esta desarrollando aplicaciones complejas o extensiones de jQuery, puede ser &uacute;til utilizar espacios de nombres para los eventos, y de esta forma evitar que se desvinculen eventos cuando no lo desea.
              </p>
              <div class="example">
                <p class="title">
                  <b>Asignar espacios de nombres a eventos</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('p').bind('click.myNamespace', function() { /* ... */ });
$('p').unbind('click.myNamespace');
$('p').unbind('.myNamespace'); // desvincula todos los eventos con el espacio de nombre 'myNamespace'
</pre>
                </div>
              </div>
            </div>
          </div>
		  <div title="Vinculaci&oacute;n de M&uacute;ltiples Eventos" class="section">
              <h3>
                Vinculaci&oacute;n de M&uacute;ltiples Eventos
              </h3>
            <p>
              Muy a menudo, elementos en una aplicaci&oacute;n estar&aacute;n vinculados a m&uacute;ltiples eventos, cada uno con una funci&oacute;n diferente. En estos casos, es posible pasar un objeto dentro de <code>$.fn.bind</code> con uno o m&aacute;s pares de nombres claves/valores. Cada nombre clave ser&aacute; el nombre del evento mientras que cada valor ser&aacute; la funci&oacute;n a ejecutar cuando ocurra el evento.
            </p>
            <div class="example">
              <p class="title">
                <b>Vincular m&uacute;ltiples eventos a un elemento</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('p').bind({
	'click': function() { console.log('clickeado'); },
	'mouseover': function() { console.log('sobrepasado'); }
});
</pre>
              </div>
            </div>
          </div>
					<div class="note">
          <h3>
            Nota
          </h3>
          <p>
            La opci&oacute;n de pasar un objeto con m&uacute;ltiples eventos y funciones a <code>$.fn.bind</code> fue introducido en jQuery 1.4.4.
          </p>
          </div>
          <div title="El Objeto del Evento" class="section">
            <h2>
              El Objeto del Evento
            </h2>
            <p>
              Como se menciona en la introducci&oacute;n, la funci&oacute;n controladora de eventos recibe un objeto del evento, el cual contiene varios m&eacute;todos y propiedades. El objeto es com&uacute;nmente utilizado para prevenir la acci&oacute;n predeterminada del evento a trav&eacute;s del m&eacute;todo <em>preventDefault</em>. Sin embargo, tambi&eacute;n contiene varias propiedades y m&eacute;todos &uacute;tiles:
            </p>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">pageX, pageY</span>
                </dt>
                <dd>
                  <p>
                    La posici&oacute;n del puntero del rat&oacute;n en el momento que el evento ocurri&oacute;, relativo a las zonas superiores e izquierda de la p&aacute;gina.
                  </p>
                </dd>
                <dt>
                  <span class="term">type</span>
                </dt>
                <dd>
                  <p>
                    El tipo de evento (por ejemplo "click").
                  </p>
                </dd>
                <dt>
                  <span class="term">which</span>
                </dt>
                <dd>
                  <p>
                    El bot&oacute;n o tecla presionada.
                  </p>
                </dd>
                <dt>
                  <span class="term">data</span>
                </dt>
                <dd>
                  <p>
                    Alguna informaci&oacute;n pasada cuando el evento es ejecutado.
                  </p>
                </dd>
                <dt>
                  <span class="term">target</span>
                </dt>
                <dd>
                  <p>
                    El elemento DOM que inicializ&oacute; el evento.
                  </p>
                </dd>
                <dt>
                  <span class="term">preventDefault()</span>
                </dt>
                <dd>
                  <p>
                    Cancela la acci&oacute;n predeterminada del evento (por ejemplo: seguir un enlace).
                  </p>
                </dd>
                <dt>
                  <span class="term">stopPropagation()</span>
                </dt>
                <dd>
                  <p>
                    Detiene la propagaci&oacute;n del evento sobre otros elementos.
                  </p>
                </dd>
              </dl>
            </div>
            <p>
              Por otro lado, la funci&oacute;n controladora tambi&eacute;n tiene acceso al elemento DOM que inicializ&oacute; el evento a trav&eacute;s de la palabra clave <code>this</code>. Para convertir a dicho elemento DOM en un objeto jQuery (y poder utilizar los m&eacute;todos de la biblioteca) es necesario escribir <code>$(this)</code>, como se muestra a continuaci&oacute;n:
            </p>
            <pre class="brush: js">
var $this = $(this);
</pre>
            <div class="example">
              <p class="title">
                <b>Cancelar que al hacer click en un enlace, &eacute;ste se siga</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('a').click(function(e) {
    var $this = $(this);
    if ($this.attr('href').match('evil')) {
        e.preventDefault();
        $this.addClass('evil');
    }
});
</pre>
              </div>
            </div>
          </div>
          <div title="Ejecuci&oacute;n autom&aacute;tica de Controladores de Eventos" class="section">
            <h2>
              Ejecuci&oacute;n autom&aacute;tica de Controladores de Eventos
            </h2>
            <p>
              A trav&eacute;s del m&eacute;todo <code>$.fn.trigger</code>, jQuery provee una manera de disparar controladores de eventos sobre alg&uacute;n elemento sin requerir la acci&oacute;n del usuario. Si bien este m&eacute;todo tiene sus usos, no deber&iacute;a ser utilizado para simplemente llamar a una funci&oacute;n que pueda ser ejecutada con un click del usuario. En su lugar, deber&iacute;a guardar la funci&oacute;n que se necesita llamar en una variable, y luego pasar el nombre de la variable cuando realiza el vinculo (<em>binding</em>). De esta forma, podr&aacute; llamar a la funci&oacute;n cuando lo desee en lugar de ejecutar <code>$.fn.trigger</code>.
            </p>
            <div class="example">
              <p class="title">
                <b>Disparar un controlador de eventos de la forma correcta</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var foo = function(e) {
    if (e) {
        console.log(e);
    } else {
        console.log('esta ejecucci&oacute;n no provino desde un evento');
    }
};


$('p').click(foo);

foo(); // en lugar de realizar $('p').trigger('click')
</pre>
              </div>
            </div>
          </div>
          <h2>
            Incrementar el Rendimiento con la Delegaci&oacute;n de Eventos
          </h2>
          <p>
            Cuando trabaje con jQuery, frecuentemente a&ntilde;adir&aacute; nuevos elementos a la p&aacute;gina, y cuando lo haga, necesitar&aacute; vincular eventos a dichos elementos &mdash; eventos que ya estaban vinculados a elementos en la p&aacute;gina. En lugar de repetir la tarea cada vez que se a&ntilde;ade un elemento, es posible utilizar la delegaci&oacute;n de eventos para hacerlo. Con ella, podr&aacute; enlazar un evento a un elemento contenedor, y luego, cuando el evento ocurra, podr&aacute; ver en que elemento sucede. Si todo esto suena complicado, afortunadamente jQuery lo hace f&aacute;cil a trav&eacute;s de los m&eacute;todos <code>$.fn.live</code> y <code>$.fn.delegate</code>.
          </p>
          <p>
            La delegaci&oacute;n de eventos posee algunos beneficios, incluso si no se tiene pensando a&ntilde;adir m&aacute;s elementos a la p&aacute;gina. El tiempo requerido para enlazar controladores de eventos a cientos de elementos no es un trabajo trivial; si posee un gran conjunto de elementos, deber&iacute;a considerar utilizar la delegaci&oacute;n de eventos a un elemento contenedor.
          </p>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            El m&eacute;todo <code>$.fn.live</code> fue introducido a partir de la versi&oacute;n 1.3 de la biblioteca y en ese momento, solo ciertos tipos de eventos eran soportados. A partir de la versi&oacute;n 1.4.2, se introdujo <code>$.fn.delegate</code> el cual es preferido a $.fn.live .
          </p>
          </div>
          <div class="example">
            <p class="title">
              <b>Delegar un evento utilizando <code>$.fn.delegate</code></b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('#myUnorderedList').delegate('li', 'click', function(e) {
    var $myListItem = $(this);
    // ...
});
</pre>
            </div>
          </div>
          <div class="example">
            <p class="title">
              <b>Delegar un Evento utilizando <code>$.fn.live</code></b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('#myUnorderedList li').live('click', function(e) {
    var $myListItem = $(this);
    // ...
});
</pre>
            </div>
          </div>
          <div title="Desvincular Eventos Delegados" class="section">
              <h3>
                Desvincular Eventos Delegados
              </h3>
            <p>
              Si necesita remover eventos delegados, no puede hacerlo simplemente desvincul&aacute;ndolos. Para eso, utilice el m&eacute;todo <code>$.fn.undelegate</code> para eventos conectados con <code>$.fn.delegate</code>, y <code>$.fn.die</code> para eventos conectados con <code>$.fn.live</code>. Al igual que cuando se realiza un vinculo, opcionalmente, se puede pasar el nombre de una funci&oacute;n vinculada.
            </p>
            <div class="example">
              <p class="title">
                <b>Desvincular eventos delegados</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myUnorderedList').undelegate('li', 'click');
$('#myUnorderedList li').die('click');
</pre>
              </div>
            </div>
          </div>
          <div title="Funciones Auxiliares de Eventos" class="section">
            <h2>
              Funciones Auxiliares de Eventos
            </h2>
            <p>
              jQuery ofrece dos funciones auxiliares para el trabajo con eventos:
            </p>
              <h3>
                <code>$.fn.hover</code>
              </h3>
            <p>
              El m&eacute;todo <code>$.fn.hover</code> permite pasar una o dos funciones que se ejecutar&aacute;n cuando los eventos <code>mouseenter</code> y <code>mouseleave</code> ocurran en el elemento seleccionado. Si se pasa una sola funci&oacute;n, est&aacute; ser&aacute; ejecutada en ambos eventos; en cambio si se pasan dos, la primera ser&aacute; ejecutada cuando ocurra el evento <code>mouseenter</code>, mientras que la segunda ser&aacute; ejecutada cuando ocurra <code>mouseleave</code>.
            </p>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              A partir de la versi&oacute;n 1.4 de jQuery, el m&eacute;todo requiere obligatoriamente dos funciones.
            </p>
            </div>
            <div class="example">
              <p class="title">
                <b>La funci&oacute;n auxiliar hover</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#menu li').hover(function() {
    $(this).toggleClass('hover');
});
</pre>
              </div>
            </div>
            <div title="$.fn.toggle" class="section">
                <h3>
                  <code>$.fn.toggle</code>
                </h3>
              <p>
                Al igual que el m&eacute;todo anterior, <code>$.fn.toggle</code> recibe dos o m&aacute;s funciones; cada vez que un evento ocurre, la funci&oacute;n siguiente en la lista se ejecutar&aacute;. Generalmente, <code>$.fn.toggle</code> es utilizada con solo dos funciones. En caso que utiliza m&aacute;s de dos funciones, tenga cuidado, ya que puede ser dificultar la depuraci&oacute;n del c&oacute;digo.
              </p>
              <div class="example">
                <p class="title">
                  <b> La funci&oacute;n auxiliar toggle</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('p.expander').toggle(
    function() {
        $(this).prev().addClass('open');
    },
    function() {
        $(this).prev().removeClass('open');
    }
);
</pre>
                </div>
              </div>
            </div>
          </div>
          <div title="Ejercicios" class="section">
            <h2>
              Ejercicios
            </h2>
            <div title="Crear una 'Sugerencia' para una Caja de Ingreso de Texto" class="section">
                <h3>
                  Crear una "Sugerencia" para una Caja de Ingreso de Texto
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/inputHint.js</code> &oacute; trabaje directamente con Firebug. La tarea a realizar es utilizar el texto del elemento label y aplicar una "sugerencia" en la caja de ingreso de texto. Los pasos ha seguir son los siguientes:
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      Establecer el valor del elemento <em>input</em> igual al valor del elemento <em>label</em>;
                    </p>
                  </li>
                  <li>
                    <p>
                      A&ntilde;adir la clase "hint" al elemento <em>input</em>;
                    </p>
                  </li>
                  <li>
                    <p>
                      Remover el elemento <em>label</em>;
                    </p>
                  </li>
                  <li>
                    <p>
                      Vincular un evento <em>focus</em> en el <em>input</em> para remover el texto de sugerencia y la clase "hint";
                    </p>
                  </li>
                  <li>
                    <p>
                      Vincular un evento <em>blur</em> en el <em>input</em> para restaurar el texto de sugerencia y la clase "hint" en caso que no se haya ingresado alg&uacute;n texto.
                    </p>
                  </li>
                </ol>
              </div>
              <p>
                ¿Qu&eacute; otras consideraciones debe considerar si se desea aplicar esta funcionalidad a un sitio real?
              </p>
            </div>
            <div title="A&ntilde;adir una Navegaci&oacute;n por Pesta&ntilde;as" class="section">
                <h3>
                  A&ntilde;adir una Navegaci&oacute;n por Pesta&ntilde;as
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/tabs.js</code> &oacute; trabaje directamente con Firebug. La tarea a realizar es crear una navegaci&oacute;n por pesta&ntilde;as para los dos elementos <em>div.module</em>. Los pasos ha seguir son los siguientes:
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      Ocultar todos los elementos <em>div.module</em>;
                    </p>
                  </li>
                  <li>
                    <p>
                      Crear una lista desordenada antes del primer <em>div.module</em> para utilizar como pesta&ntilde;as;
                    </p>
                  </li>
                  <li>Interactuar con cada div utilizando <code>$.fn.each</code>. Por cada uno, utilizar el texto del elemento <em>h2</em> como el texto para el &iacute;tem de la lista desordenada;
                  </li>
                  <li>
                    <p>
                      Vincular un evento <em>click</em> a cada &iacute;tem de la lista de forma que:
                    </p>
                    <ul>
                      <li>
                        <p>
                          Muestre el <em>div</em> correspondiente y oculte el otro;
                        </p>
                      </li>
                      <li>
                        <p>
                          A&ntilde;ada la clase "current" al &iacute;tem seleccionado;
                        </p>
                      </li>
                      <li>
                        <p>
                          Remueva la clase "current" del otro &iacute;tem de la lista;
                        </p>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>
                      Finalmente, mostrar la primera pesta&ntilde;a.
                    </p>
                  </li>
                </ol>
              </div>
            </div>
          </div>
        </div>        <div id="capitulo-6" title="Efectos" class="chapter">
			<h2 class="title">Efectos</h2>
          <div title="Introducci&oacute;n" class="section">
            <h2>
              Introducci&oacute;n
            </h2>
            <p>
              Con jQuery, agregar efectos a una p&aacute;gina es muy f&aacute;cil. Estos efectos poseen una configuraci&oacute;n predeterminada pero tambi&eacute;n es posible proveerles par&aacute;metros personalizados. Adem&aacute;s es posible crear animaciones particulares estableciendo valores de propiedades CSS.
            </p>
            <p>
              Para una completa documentaci&oacute;n sobre los diferentes tipos de efectos puede visitar <a href="http://api.jquery.com/category/effects/">http://api.jquery.com/category/effects/</a>.
            </p>
          </div>
          <div title="Efectos Incorporados en la Biblioteca" class="section">
            <h2>
              Efectos Incorporados en la Biblioteca
            </h2>
            <p>
              Los efectos m&aacute;s utilizado ya vienen incorporados dentro de la biblioteca en forma de m&eacute;todos:
            </p>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">$.fn.show</span>
                </dt>
                <dd>
                  <p>
                    Muestra el elemento seleccionado.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.hide</span>
                </dt>
                <dd>
                  <p>
                    Oculta el elemento seleccionado.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.fadeIn</span>
                </dt>
                <dd>
                  <p>
                    De forma animada, cambia la opacidad del elemento seleccionado al 100%.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.fadeOut</span>
                </dt>
                <dd>
                  <p>
                    De forma animada, cambia la opacidad del elemento seleccionado al 0
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.slideDown</span>
                </dt>
                <dd>
                  <p>
                    Muestra el elemento seleccionado con un movimiento de deslizamiento vertical.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.slideUp</span>
                </dt>
                <dd>
                  <p>
                    Oculta el elemento seleccionado con un movimiento de deslizamiento vertical.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.slideToggle</span>
                </dt>
                <dd>
                  <p>
                    Muestra o oculta el elemento seleccionado con un movimiento de deslizamiento vertical, dependiendo si actualmente el elemento est&aacute; visible o no.
                  </p>
                </dd>
              </dl>
            </div>
            <div class="example">
              <p class="title">
                <b>Uso b&aacute;sico de un efecto incorporado</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('h1').show();
</pre>
              </div>
            </div>
            <div title="Cambiar la Duraci&oacute;n de los Efectos" class="section">
                <h3>
                  Cambiar la Duraci&oacute;n de los Efectos
                </h3>
              <p>
                Con la excepci&oacute;n de <code>$.fn.show</code> y <code>$.fn.hide</code>, todos los m&eacute;todos tienen una duraci&oacute;n predeterminada de la animaci&oacute;n en 400ms. Este valor es posible cambiarlo.
              </p>
              <div class="example">
                <p class="title">
                  <b>Configurar la duraci&oacute;n de un efecto</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('h1').fadeIn(300);      // desvanecimiento en 300ms
$('h1').fadeOut('slow');  // utilizar una definici&oacute;n de velocidad interna
</pre>
                </div>
              </div>
              <div title="jQuery.fx.speeds" class="section">
                  <h4>
                    jQuery.fx.speeds
                  </h4>
                <p>
                  jQuery posee un objeto en <code>jQuery.fx.speeds</code> el cual contiene la velocidad predeterminada para la duraci&oacute;n de un efecto, as&iacute; como tambi&eacute;n los valores para las definiciones <em>"slow"</em> y <em>"fast"</em>.
                </p>
                <pre class="brush: js">
speeds: {
    slow: 600,
    fast: 200,
    // velocidad predeterminada
    _default: 400
}
</pre>
                <p>
                  Por lo tanto, es posible sobrescribir o a&ntilde;adir nuevos valores al objeto. Por ejemplo, puede que quiera cambiar el valor predeterminado del efecto o a&ntilde;adir una velocidad personalizada.
                </p>
                <div class="example">
                  <p class="title">
                    <b>A&ntilde;adir velocidades personalizadas a <code>jQuery.fx.speeds</code></b>
                  </p>
                  <div class="example-contents">
                    <pre class="brush: js">
jQuery.fx.speeds.muyRapido = 100;
jQuery.fx.speeds.muyLento = 2000;
</pre>
                  </div>
                </div>
              </div>
            </div>
            <div title="Realizar una Acci&oacute;n Cuando un Efecto fue Ejecutado" class="section">
                <h3>
                  Realizar una Acci&oacute;n Cuando un Efecto fue Ejecutado
                </h3>
              <p>
                A menudo, querr&aacute; ejecutar una acci&oacute;n una vez que la animaci&oacute;n haya terminado &mdash; ya que si ejecuta la acci&oacute;n antes que la animaci&oacute;n haya acabado, puede llegar a alterar la calidad del efecto o afectar a los elementos que forman parte de la misma. <span class="termdef">[Definici&oacute;n: <em class="firstterm">Las funciones de devoluci&oacute;n de llamada</em> (en ingl&eacute;s <em>callback functions</em>) proveen una forma para ejecutar c&oacute;digo una vez que un evento haya terminado.]</span> En este caso, el evento que responder&aacute; a la funci&oacute;n ser&aacute; la conclusi&oacute;n de la animaci&oacute;n. Dentro de la funci&oacute;n de devoluci&oacute;n, la palabra clave <code>this</code> hace referencia al elemento en donde el efecto fue ejecutado y al igual que sucede con los eventos, es posible transformarlo a un objeto jQuery utilizando <code>$(this)</code>.
              </p>
              <div class="example">
                <p class="title">
                  <b>Ejecutar cierto c&oacute;digo cuando una animaci&oacute;n haya concluido</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('div.old').fadeOut(300, function() { $(this).remove(); });
</pre>
                </div>
              </div>
              <p>
                Note que si la selecci&oacute;n no retorna ning&uacute;n elemento, la funci&oacute;n nunca se ejecutar&aacute;. Este problema lo puede resolver comprobando si la selecci&oacute;n devuelve alg&uacute;n elemento; y en caso que no lo haga, ejecutar la funci&oacute;n de devoluci&oacute;n inmediatamente.
              </p>
              <div class="example">
                <p class="title">
                  <b>Ejecutar una funci&oacute;n de devoluci&oacute;n incluso si no hay elementos para animar</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var $thing = $('#nonexistent');

var cb = function() {
    console.log('realizado');
};

if ($thing.length) {
    $thing.fadeIn(300, cb);
} else {
    cb();
}
</pre>
                </div>
              </div>
            </div>
          </div>
          <h2>
            Efectos Personalizados con <code>$.fn.animate</code>
          </h2>
          <p>
            Es posible realizar animaciones en propiedades CSS utilizando el m&eacute;todo <code>$.fn.animate</code>. Dicho m&eacute;todo permite realizar una animaci&oacute;n estableciendo valores a propiedades CSS o cambiando sus valores actuales.
          </p>
          <div class="example">
            <p class="title">
              <b>Efectos personalizados con <code>$.fn.animate</code></b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$('div.funtimes').animate(
    {
        left : "+=50",
        opacity : 0.25
    },
    300, // duration
    function() { console.log('realizado'); // funci&oacute;n de devoluci&oacute;n de llamada
});
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Las propiedades relacionadas al color no pueden ser animadas utilizando el m&eacute;todo <code>$.fn.animate</code>, pero es posible hacerlo a trav&eacute;s de la extensi&oacute;n <a href="http://plugins.jquery.com/files/jquery.color.js.txt">color plugin</a>. M&aacute;s adelante en el libro de discutir&aacute; la utilizaci&oacute;n de extensiones.
          </p>
          </div>
          <div title="Easing" class="section">
              <h3>
                Easing
              </h3>
            <p>
              <span class="termdef">[Definici&oacute;n: 
              El concepto de <em
              class="firstterm">Easing</em> describe la manera en que un efecto ocurre &mdash; es decir, si la velocidad durante la animaci&oacute;n es constante o no.]</span> jQuery incluye solamente dos m&eacute;todos de easing: <em>swing</em> y <em>linear</em>. Si desea transiciones m&aacute;s naturales en las animaciones, existen varias extensiones que lo permiten.
            </p>
            <p>
              A partir de la versi&oacute;n 1.4 de la biblioteca, es posible establecer el tipo de transici&oacute;n por cada propiedad utilizando el m&eacute;todo <code>$.fn.animate</code>.
            </p>
            <div class="example">
              <p class="title">
                <b>Transici&oacute;n de easing por cada propiedad</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('div.funtimes').animate(
    {
        left : [ "+=50", "swing" ],
        opacity : [ 0.25, "linear" ]
    },
    300
);
</pre>
              </div>
            </div>
            <p>
              Para m&aacute;s detalles sobre las opciones de easing, consulte <a href="http://api.jquery.com/animate/">http://api.jquery.com/animate/</a>.
            </p>
          </div>
          <div title="Control de los Efectos" class="section">
            <h2>
              Control de los Efectos
            </h2>
            <p>
              jQuery provee varias herramientas para el manejo de animaciones.
            </p>
            <div class="variablelist">
              <dl>
                <dt>
                  <span class="term">$.fn.stop</span>
                </dt>
                <dd>
                  <p>
                    Detiene las animaciones que se est&aacute;n ejecutando en el elemento seleccionado.
                  </p>
                </dd>
                <dt>
                  <span class="term">$.fn.delay</span>
                </dt>
                <dd>
                  <p>
                    Espera un tiempo determinado antes de ejecutar la pr&oacute;xima animaci&oacute;n.
                  </p>
                  <pre class="brush: js">
$('h1').show(300).delay(1000).hide(300);
</pre>
                </dd>
                <dt>
                  <span class="term">jQuery.fx.off</span>
                </dt>
                <dd>
                  <p>
                    Si el valor es verdadero (<em>true</em>), no existir&aacute;n transiciones para las animaciones; y a los elementos se le establecer&aacute; el estado final de la animaci&oacute;n. Este m&eacute;todo puede ser especialmente &uacute;til cuando se esta trabajando con navegadores antiguos.
                  </p>
                </dd>
              </dl>
            </div>
          </div>
          <div title="Ejercicios" class="section">
            <h2>
              Ejercicios
            </h2>
            <div title="Mostrar Texto Oculto" class="section">
                <h3>
                  Mostrar Texto Oculto
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/blog.js</code>. La tarea es a&ntilde;adir alguna interactividad a la secci&oacute;n blog de la p&aacute;gina:
              </p>
              <ul>
                <li>
                  <p>
                    Al hacer click en alguno de los titulares del <em>div #blog</em>, se debe mostrar el p&aacute;rrafo correspondiente con un efecto de deslizamiento;
                  </p>
                </li>
                <li>
                  <p>
                    Al hacer click en otro titular, se debe ocultar el p&aacute;rrafo mostrado con un efecto de deslizamiento y mostrar nuevamente el p&aacute;rrafo correspondiente tambi&eacute;n con un efecto de deslizamiento.
                  </p>
                </li>
              </ul>
              <p>
                Ayuda: No se olvide de utilizar el selector <code>:visible</code>.
              </p>
            </div>
            <div title="Crear un Men&uacute; Desplegable" class="section">
                <h3>
                  Crear un Men&uacute; Desplegable
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/navigation.js</code>. La tarea es poder desplegar los &iacute;tems del men&uacute; superior de la p&aacute;gina:
              </p>
              <ul>
                <li>
                  <p>
                    Al pasar el puntero del rat&oacute;n por encima de un &iacute;tem del men&uacute;, se debe mostrar su submen&uacute; en caso que exista;
                  </p>
                </li>
                <li>
                  <p>
                    Al no estar m&aacute;s encima de un &iacute;tem, el submen&uacute; se debe ocultar.
                  </p>
                </li>
              </ul>
              <p>
                Para poder realizarlo, utilice el m&eacute;todo <code>$.fn.hover</code> para a&ntilde;adir o remover una clase en el submen&uacute; para poder controlar si debe estar oculto o visible (El archivo <code class="filename">/exercises/css/styles.css</code> incluye una clase "hover" para este prop&oacute;sito)
              </p>
            </div>
            <div title="Crear un Slideshow" class="section">
                <h3>
                  Crear un Slideshow
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/slideshow.js</code>. La tarea es a&ntilde;adir un slideshow a la p&aacute;gina con JavaScript.
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      Mover el elemento <em>#slideshow</em> a la parte superior de la p&aacute;gina;
                    </p>
                  </li>
                  <li>
                    <p>
                      Escribir un c&oacute;digo que permita mostrar los &iacute;tems de forma c&iacute;clica, mostrando un &iacute;tem por unos segundos, luego ocult&aacute;ndolo con un efecto <em>fade out</em> y mostrando el siguiente con un efecto <em>fade in</em>;
                    </p>
                  </li>
                  <li>
                    <p>
                      Una vez llegado al &uacute;ltimo &iacute;tem de la lista, comenzar de nuevo con el primero;
                    </p>
                  </li>
                </ol>
              </div>
              <p>
                Para un desaf&iacute;o mayor, realice un &aacute;rea de navegaci&oacute;n por debajo del slideshow que muestre cuantas im&aacute;genes existen y en cual se encuentra (ayuda: <code>$.fn.prevAll</code> puede resultar &uacute;til)
              </p>
            </div>
          </div>
        </div>        <div id="capitulo-7" title="Ajax" class="chapter">
			<h2 class="title">Ajax</h2>
          <div title="Introducci&oacute;n" class="section">
            <h2>
              Introducci&oacute;n
            </h2>
            <p>
              El m&eacute;todo <em>XMLHttpRequest</em> (XHR) permite a los navegadores comunicarse con el servidor sin la necesidad de recargar la p&aacute;gina. Este m&eacute;todo, tambi&eacute;n conocido como Ajax (JavaScript as&iacute;ncrono y XML, en ingl&eacute;s <em>Asynchronous JavaScript and XML</em>), permite la creaci&oacute;n de aplicaciones ricas en interactividad.
            </p>
            <p>
              Las peticiones Ajax son ejecutadas por el c&oacute;digo JavaScript, el cual env&iacute;a una petici&oacute;n a una URL y cuando recibe una respuesta, una funci&oacute;n de devoluci&oacute;n puede ser ejecutada la cual recibe como argumento la respuesta del servidor y realiza algo con ella. Debido a que la respuesta es as&iacute;ncrona, el resto del c&oacute;digo de la aplicaci&oacute;n continua ejecut&aacute;ndose, por lo cual, es imperativo que una funci&oacute;n de devoluci&oacute;n sea ejecutada para manejar la respuesta.
            </p>
            <p>
              A trav&eacute;s de varios m&eacute;todos, jQuery provee soporte para Ajax, permitiendo abstraer las diferencias que pueden existir entre navegadores. Los m&eacute;todos en cuesti&oacute;n son <code>$.get()</code>, <code>$.getScript()</code>, <code>$.getJSON()</code>, <code>$.post()</code> y <code>$().load()</code>.
            </p>
            <p>
              A pesar que la definici&oacute;n de Ajax posee la palabra "XML", la mayor&iacute;a de las aplicaciones no utilizan dicho formato para el transporte de datos, sino que en su lugar se utiliza HTML plano o informaci&oacute;n en formato JSON (<em>JavaScript Object Notation</em>).
            </p>
            <p>
              En general, Ajax no trabaja a trav&eacute;s de dominios diferentes. Sin embargo, existen excepciones, como los servicios que proveen informaci&oacute;n en formato JSONP (<em>JSON with Padding</em>), los cuales permiten una funcionalidad limitada a trav&eacute;s de diferentes dominios.
            </p>
          </div>
          <div title="Conceptos Clave" class="section">
            <h2>
              Conceptos Clave
            </h2>
            <p>
              La utilizaci&oacute;n correcta de los m&eacute;todos Ajax requiere primero la comprensi&oacute;n de algunos conceptos clave.
            </p>
            <div title="GET vs. POST" class="section">
                <h3>
                  GET vs. POST
                </h3>
              <p>
                Los dos m&eacute;todos HTTP m&aacute;s comunes para enviar una petici&oacute;n a un servidor son GET y POST. Es importante entender la utilizaci&oacute;n de cada uno.
              </p>
              <p>
                El m&eacute;todo GET debe ser utilizado para operaciones no-destructivas — es decir, operaciones en donde se esta "obteniendo" datos del servidor, pero no modificando. Por ejemplo, una consulta a un servicio de b&uacute;squeda podr&iacute;a ser una petici&oacute;n GET. Por otro lado, las solicitudes GET pueden ser almacenadas en la cache del navegador, pudiendo conducir a un comportamiento impredecible si no se lo espera. Generalmente, la informaci&oacute;n enviada al servidor, es enviada en una cadena de datos (en ingl&eacute;s <em>query string</em>).
              </p>
              <p>
                El m&eacute;todo POST debe ser utilizado para operaciones destructivas — es decir, operaciones en donde se est&aacute; incorporando informaci&oacute;n al servidor. Por ejemplo, cuando un usuario guarda un art&iacute;culo en un blog, esta acci&oacute;n deber&iacute;a utilizar POST. Por otro lado, este tipo de m&eacute;todo no se guarda en la cache del navegador. Adem&aacute;s, una cadena de consulta puede ser parte de la URL, pero la informaci&oacute;n tiende a ser enviada de forma separada.
              </p>
            </div>
            <div title="Tipos de Datos" class="section">
                <h3>
                  Tipos de Datos
                </h3>
              <p>
                Generalmente, jQuery necesita algunas instrucciones sobre el tipo de informaci&oacute;n que se espera recibir cuando se realiza una petici&oacute;n Ajax. En algunos casos, el tipo de dato es especificado por el nombre del m&eacute;todo, pero en otros casos se lo debe detallar como parte de la configuraci&oacute;n del m&eacute;todo:
              </p>
              <div class="variablelist">
                <dl>
                  <dt>
                    <span class="term">text</span>
                  </dt>
                  <dd>
                    <p>
                      Para el transporte de cadenas de caracteres simples.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">html</span>
                  </dt>
                  <dd>
                    <p>
                      Para el transporte de bloques de c&oacute;digo HTML que ser&aacute;n ubicados en la p&aacute;gina.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">script</span>
                  </dt>
                  <dd>
                    <p>
                      Para a&ntilde;adir un nuevo <em>script</em> con c&oacute;digo JavaScript a la p&aacute;gina.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">json</span>
                  </dt>
                  <dd>
                    <p>
                      Para transportar informaci&oacute;n en formato JSON, el cual puede incluir cadenas de caracteres, arreglos y objetos.
                    </p>
                    <div class="note">
                    <h3>
                      Nota
                    </h3>
                    <p>
                      A partir de la versi&oacute;n 1.4 de la biblioteca, si la informaci&oacute;n JSON no est&aacute; correctamente formateada, la petici&oacute;n podr&iacute;a fallar. Visite <a href="http://json.org">http://json.org</a> para obtener detalles sobre un correcto formateo de datos en JSON.
                    </p>
                    <p>
                      Es recomendable utilizar los mecanismos que posea el lenguaje del lado de servidor para la generaci&oacute;n de informaci&oacute;n en JSON.
                    </p>
                    </div>
                  </dd>
                  <dt>
                    <span class="term">jsonp</span>
                  </dt>
                  <dd>
                    <p>
                      Para transportar informaci&oacute;n JSON de un dominio a otro.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">xml</span>
                  </dt>
                  <dd>
                    <p>
                      Para transportar informaci&oacute;n en formato XML.
                    </p>
                  </dd>
                </dl>
              </div>
              <p class="remark">
                <i><span class="remark">A pesar de los diferentes tipos de datos de que se puede utilizar, es recomendable utilizar el formato JSON, ya que &eacute;ste es muy flexible, permitiendo por ejemplo, enviar al mismo tiempo informaci&oacute;n plana y HTML.</span></i>
              </p>
            </div>
            <div title="Asincronismo" class="section">
                <h3>
                  Asincronismo
                </h3>
              <p>
                Debido a que, de forma predeterminada, las llamadas Ajax son as&iacute;ncronas, la respuesta del servidor no esta disponible de forma inmediata. Por ejemplo, el siguiente c&oacute;digo no deber&iacute;a funcionar:
              </p>
              <pre class="brush: js">
var response;
$.get('foo.php', function(r) { response = r; });
console.log(response); // indefinido (undefined)
</pre>
              <p>
                En su lugar, es necesario especificar una funci&oacute;n de devoluci&oacute;n de llamada; dicha funci&oacute;n se ejecutar&aacute; cuando la petici&oacute;n se haya realizado de forma correcta ya que es en ese momento cuando la respuesta del servidor esta lista.
              </p>
              <pre class="brush: js">
$.get('foo.php', function(response) { console.log(response); });
</pre>
            </div>
            <div title="Pol&iacute;ticas de Mismo Origen y JSONP" class="section">
                <h3>
                  Pol&iacute;ticas de Mismo Origen y JSONP
                </h3>
              <p>
                En general, las peticiones Ajax est&aacute;n limitadas a utilizar el mismo protocolo (<em>http</em> o <em>https</em>), el mismo puerto y el mismo dominio de origen. Esta limitaci&oacute;n no se aplica a los scripts cargados a trav&eacute;s del m&eacute;todo Ajax de jQuery.
              </p>
              <p>
                La otra excepci&oacute;n es cuando se hace una petici&oacute;n que recibir&aacute; una respuesta en formato JSONP. En este caso, el proveedor de la respuesta debe responder la petici&oacute;n con un <code>script</code> que puede ser cargado utilizando la etiqueta <code>&lt;script&gt;</code>, evitando as&iacute; la limitaci&oacute;n de realizar peticiones desde el mismo dominio. Dicha respuesta contendr&aacute; la informaci&oacute;n solicitada, contenida en una funci&oacute;n
              </p>
            </div>
            <div title="Ajax y Firebug" class="section">
                <h3>
                  Ajax y Firebug
                </h3>
              <p>
                Firebug (o el inspector WebKit que viene incluido en Chrome o Safari) son herramientas imprescindibles para trabajar con peticiones Ajax, ya que es posible observarlas desde la pesta&ntilde;a Consola de Firebug (o yendo a Recursos &gt; Panel XHR desde el inspector de Webkit) y revisar los detalles de dichas peticiones. Si algo esta fallando cuando trabaja con Ajax, este es el primer lugar en donde debe dirigirse para saber cual es el problema.
              </p>
            </div>
          </div>
          <div title="M&eacute;todos Ajax de jQuery" class="section">
            <h2>
              M&eacute;todos Ajax de jQuery
            </h2>
            <p>
              Como se indic&oacute; anteriormente, jQuery posee varios m&eacute;todos para trabajar con Ajax. Sin embargo, todos est&aacute;n basados en el m&eacute;todo <code>$.ajax</code>, por lo tanto, su comprensi&oacute;n es obligatoria. A continuaci&oacute;n se abarcar&aacute; dicho m&eacute;todo y luego se indicar&aacute; un breve resumen sobre los dem&aacute;s m&eacute;todos.
            </p>
            <p class="remark">
              <i><span class="remark">Generalmente, es preferible utilizar el m&eacute;todo $.ajax en lugar de los otros, ya que ofrece m&aacute;s caracter&iacute;sticas y su configuraci&oacute;n es muy comprensible.</span></i>
            </p>
              <h3>
                $.ajax
              </h3>
            <p>
              El m&eacute;todo <code>$.ajax</code> es configurado a trav&eacute;s de un objeto, el cual contiene todas las instrucciones que necesita jQuery para completar la petici&oacute;n. Dicho m&eacute;todo es particularmente &uacute;til debido a que ofrece la posibilidad de especificar acciones en caso que la petici&oacute;n haya fallado o no. Adem&aacute;s, al estar configurado a trav&eacute;s de un objeto, es posible definir sus propiedades de forma separada, haciendo que sea m&aacute;s f&aacute;cil la reutilizaci&oacute;n del c&oacute;digo. Puede visitar <a href="http://api.jquery.com/jQuery.ajax/">http://api.jquery.com/jQuery.ajax/</a> para consultar la documentaci&oacute;n sobre las opciones disponibles en el m&eacute;todo.
            </p>
            <div class="example">
              <p class="title">
                <b>Utilizar el m&eacute;todo $.ajax</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$.ajax({
    // la URL para la petici&oacute;n
    url : 'post.php',

    // la informaci&oacute;n a enviar
    // (tambi&eacute;n es posible utilizar una cadena de datos)
    data : { id : 123 },

    // especifica si ser&aacute; una petici&oacute;n POST o GET
    type : 'GET',

    // el tipo de informaci&oacute;n que se espera de respuesta
    dataType : 'json',

    // c&oacute;digo a ejecutar si la petici&oacute;n es satisfactoria;
    // la respuesta es pasada como argumento a la funci&oacute;n
    success : function(json) {
        $('&lt;h1/&gt;').text(json.title).appendTo('body');
        $('&lt;div class="content"/&gt;')
            .html(json.html).appendTo('body');
    },

    // c&oacute;digo a ejecutar si la petici&oacute;n falla;
    // son pasados como argumentos a la funci&oacute;n
    // el objeto de la petici&oacute;n en crudo y c&oacute;digo de estatus de la petici&oacute;n
    error : function(xhr, status) {
        alert('Disculpe, existi&oacute; un problema');
    },

    // c&oacute;digo a ejecutar sin importar si la petici&oacute;n fall&oacute; o no
    complete : function(xhr, status) {
        alert('Petici&oacute;n realizada');
    }
});
</pre>
              </div>
            </div>
            <div class="note">
            <h3>
              Nota
            </h3>
            <p>
              Una aclaraci&oacute;n sobre el par&aacute;metro <code>dataType</code>: Si el servidor devuelve informaci&oacute;n que es diferente al formato especificado, el c&oacute;digo fallar&aacute;, y la raz&oacute;n de porque lo hace no siempre quedar&aacute; clara debido a que la respuesta HTTP no mostrar&aacute; ning&uacute;n tipo de error. Cuando est&eacute; trabajando con peticiones Ajax, debe estar seguro que el servidor esta enviando el tipo de informaci&oacute;n que esta solicitando y verifique que la cabecera Content-type es exacta al tipo de dato. Por ejemplo, para informaci&oacute;n en formato JSON, la cabecera Content-type deber&iacute;a ser <code>application/json</code>.
            </p>
            </div>
            <div title="Opciones del m&eacute;todo $.ajax" class="section">
                <h4>
                  Opciones del m&eacute;todo <code>$.ajax</code>
                </h4>
              <p>
                El m&eacute;todo $.ajax posee muchas opciones de configuraci&oacute;n, y es justamente esta caracter&iacute;stica la que hace que sea un m&eacute;todo muy &uacute;til. Para una lista completa de las opciones disponibles, puede consultar <a href="http://api.jquery.com/jQuery.ajax/">http://api.jquery.com/jQuery.ajax/</a>; a continuaci&oacute;n se muestran las m&aacute;s comunes:
              </p>
              <div class="variablelist">
                <dl>
                  <dt>
                    <span class="term">async</span>
                  </dt>
                  <dd>
                    <p>
                      Establece si la petici&oacute;n ser&aacute; as&iacute;ncrona o no. De forma predeterminada el valor es <code>true</code>. Debe tener en cuenta que si la opci&oacute;n se establece en <code>false</code>, la petici&oacute;n bloquear&aacute; la ejecuci&oacute;n de otros c&oacute;digos hasta que dicha petici&oacute;n haya finalizado.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">cache</span>
                  </dt>
                  <dd>
                    <p>
                      Establece si la petici&oacute;n ser&aacute; guardada en la cache del navegador. De forma predeterminada es <code>true</code> para todos los <em>dataType</em> excepto para "<em>script</em>" y "<em>jsonp</em>". Cuando posee el valor false, se agrega una cadena de caracteres anti-cache al final de la URL de la petici&oacute;n.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">complete</span>
                  </dt>
                  <dd>
                    <p>
                      Establece una funci&oacute;n de devoluci&oacute;n de llamada que se ejecuta cuando la petici&oacute;n esta completa, aunque haya fallado o no. La funci&oacute;n recibe como argumentos el objeto de la petici&oacute;n en crudo y el c&oacute;digo de estatus de la misma petici&oacute;n.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">context</span>
                  </dt>
                  <dd>
                    <p>
                      Establece el alcance en que la/las funciones de devoluci&oacute;n de llamada se ejecutaran (por ejemplo, define el significado de <code>this</code> dentro de las funciones). De manera predeterminada <code>this</code> hace referencia al objeto originalmente pasado al m&eacute;todo <code>$.ajax</code>.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">data</span>
                  </dt>
                  <dd>
                    <p>
                      Establece la informaci&oacute;n que se enviar&aacute; al servidor. Esta puede ser tanto un objeto como una cadena de datos (por ejemplo <code>foo=bar&amp;baz=bim</code>.)
                    </p>
                  </dd>
                  <dt>
                    <span class="term">dataType</span>
                  </dt>
                  <dd>
                    <p>
                      Establece el tipo de informaci&oacute;n que se espera recibir como respuesta del servidor. Si no se especifica ning&uacute;n valor, de forma predeterminada, jQuery revisa el tipo de <em>MIME</em> que posee la respuesta.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">error</span>
                  </dt>
                  <dd>
                    <p>
                      Establece una funci&oacute;n de devoluci&oacute;n de llamada a ejecutar si resulta alg&uacute;n error en la petici&oacute;n. Dicha funci&oacute;n recibe como argumentos el objeto de la petici&oacute;n en crudo y el c&oacute;digo de estatus de la misma petici&oacute;n.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">jsonp</span>
                  </dt>
                  <dd>
                    <p>
                      Establece el nombre de la funci&oacute;n de devoluci&oacute;n de llamada a enviar cuando se realiza una petici&oacute;n <em>JSONP</em>. De forma predeterminada el nombre es "<em>callback</em>
                    </p>
                  </dd>
                  <dt>
                    <span class="term">success</span>
                  </dt>
                  <dd>
                    <p>
                      Establece una funci&oacute;n a ejecutar si la petici&oacute;n a sido satisfactoria. Dicha funci&oacute;n recibe como argumentos la informaci&oacute;n de la petici&oacute;n (convertida a objeto JavaScript en el caso que <em>dataType</em> sea <em>JSON</em>), el estatus de la misma y el objeto de la petici&oacute;n en crudo.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">timeout</span>
                  </dt>
                  <dd>
                    <p>
                      Establece un tiempo en milisegundos para considerar a una petici&oacute;n como fallada.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">traditional</span>
                  </dt>
                  <dd>
                    <p>
                      Si su valor es true, se utiliza el estilo de serializaci&oacute;n de datos utilizado antes de jQuery 1.4. Para m&aacute;s detalles puede visitar <a href="http://api.jquery.com/jQuery.param/">http://api.jquery.com/jQuery.param/</a>.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">type</span>
                  </dt>
                  <dd>
                    <p>
                      De forma predeterminada su valor es "GET". Otros tipos de peticiones tambi&eacute;n pueden ser utilizadas (como PUT y DELETE), sin embargo pueden no estar soportados por todos los navegadores.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">url</span>
                  </dt>
                  <dd>
                    <p>
                      Establece la URL en donde se realiza la petici&oacute;n.
                    </p>
                  </dd>
                </dl>
              </div>
              <p>
                La opci&oacute;n <code>url</code> es obligatoria para el m&eacute;todo <code>$.ajax</code>;
              </p>
            </div>
            <div title="M&eacute;todos Convenientes" class="section">
                <h3>
                  M&eacute;todos Convenientes
                </h3>
              <p>
                En caso que no quiera utilizar el m&eacute;todo <code>$.ajax</code>, y no necesite los controladores de errores, existen otros m&eacute;todos m&aacute;s convenientes para realizar peticiones Ajax (aunque, como se indic&oacute; antes, estos est&aacute;n basados el m&eacute;todo <code>$.ajax</code> con valores pre-establecidos de configuraci&oacute;n).
              </p>
              <p>
                Los m&eacute;todos que provee la biblioteca son:
              </p>
              <div class="variablelist">
                <dl>
                  <dt>
                    <span class="term">$.get</span>
                  </dt>
                  <dd>
                    <p>
                      Realiza una petici&oacute;n GET a una URL provista.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">$.post</span>
                  </dt>
                  <dd>
                    <p>
                      Realiza una petici&oacute;n POST a una URL provista.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">$.getScript</span>
                  </dt>
                  <dd>
                    <p>
                      A&ntilde;ade un script a la p&aacute;gina.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">$.getJSON</span>
                  </dt>
                  <dd>
                    <p>
                      Realiza una petici&oacute;n GET a una URL provista y espera que un dato JSON sea devuelto.
                    </p>
                  </dd>
                </dl>
              </div>
              <p>
                Los m&eacute;todos deben tener los siguientes argumentos, en orden:
              </p>
              <div class="variablelist">
                <dl>
                  <dt>
                    <span class="term">url</span>
                  </dt>
                  <dd>
                    <p>
                      La URL en donde se realizar&aacute; la petici&oacute;n. Su valor es obligatorio.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">data</span>
                  </dt>
                  <dd>
                    <p>
                      La informaci&oacute;n que se enviar&aacute; al servidor. Su valor es opcional y puede ser tanto un objeto como una cadena de datos (como <code>foo=bar&amp;baz=bim</code>).
                    </p>
                    <div class="note">
                    <h3>
                      Nota
                    </h3>
                    <p>
                      Esta opci&oacute;n no es valida para el m&eacute;todo <code>$.getScript</code>.
                    </p>
                    </div>
                  </dd>
                  <dt>
                    <span class="term">success callback</span>
                  </dt>
                  <dd>
                    <p>
                      Una funci&oacute;n opcional que se ejecuta en caso que petici&oacute;n haya sido satisfactoria. Dicha funci&oacute;n recibe como argumentos la informaci&oacute;n de la petici&oacute;n y el objeto en bruto de dicha petici&oacute;n.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">data type</span>
                  </dt>
                  <dd>
                    <p>
                      El tipo de dato que se espera recibir desde el servidor. Su valor es opcional.
                    </p>
                    <div class="note">
                    <h3>
                      Nota
                    </h3>
                    <p>
                      Esta opci&oacute;n es solo aplicable para m&eacute;todos en que no est&aacute; especificado el tipo de dato en el nombre del mismo m&eacute;todo.
                    </p>
                    </div>
                  </dd>
                </dl>
              </div>
              <div class="example">
                <p class="title">
                  <b>Utilizar m&eacute;todos convenientes para peticiones Ajax</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
// obtiene texto plano o html
$.get('/users.php', { userId : 1234 }, function(resp) {
    console.log(resp);
});

// a&ntilde;ade un script a la p&aacute;gina y luego ejecuta la funci&oacute;n especificada
$.getScript('/static/js/myScript.js', function() {
    functionFromMyScript();
});

// obtiene informaci&oacute;n en formato JSON desde el servidor
$.getJSON('/details.php', function(resp) {
    $.each(resp, function(k, v) {
        console.log(k + ' : ' + v);
    });
});
</pre>
                </div>
              </div>
            </div>
            <div title="$.fn.load" class="section">
                <h3>
                  <code>$.fn.load</code>
                </h3>
              <p>
                El m&eacute;todo <code>$.fn.load</code> es el &uacute;nico que se puede llamar desde una selecci&oacute;n. Dicho m&eacute;todo obtiene el c&oacute;digo HTML de una URL y rellena a los elementos seleccionados con la informaci&oacute;n obtenida. En conjunto con la URL, es posible especificar opcionalmente un selector, el cual obtendr&aacute; el c&oacute;digo especificado en dicha selecci&oacute;n.
              </p>
              <div class="example">
                <p class="title">
                  <b>Utilizar el m&eacute;todo <code>$.fn.load</code> para rellenar un elemento</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('#newContent').load('/foo.html');
</pre>
                </div>
              </div>
              <div class="example">
                <p class="title">
                  <b>Utilizar el m&eacute;todo <code>$.fn.load</code> para rellenar un elemento basado en un selector</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$('#newContent').load('/foo.html #myDiv h1:first', function(html) {
  alert('Contenido actualizado');
});
</pre>
                </div>
              </div>
            </div>
          </div>
          <div title="Ajax y Formularios" class="section">
            <h2>
              Ajax y Formularios
            </h2>
            <p>
              Las capacidades de jQuery con Ajax pueden ser especialmente &uacute;tiles para el trabajo con formularios. Por ejemplo, el plugin <a href="http://jquery.malsup.com/form/">jQuery Form Plugin</a> es una extensi&oacute;n para a&ntilde;adir capacidades Ajax a formularios. Existen dos m&eacute;todos que debe conocer para cuando este realizando este tipo de trabajos: <code>$.fn.serialize</code> y <code>$.fn.serializeArray</code>.
            </p>
            <div class="example">
              <p class="title">
                <b>Transformar informaci&oacute;n de un formulario a una cadena de datos</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myForm').serialize();
</pre>
              </div>
            </div>
            <div class="example">
              <p class="title">
                <b>Crear un arreglo de objetos conteniendo informaci&oacute;n de un formulario</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#myForm').serializeArray();

// crea una estructura como esta:
[
    { name : 'field1', value : 123 },
    { name : 'field2', value : 'hello world' }
]
</pre>
              </div>
            </div>
          </div>
          <div title="Trabajar con JSONP" class="section">
            <h2>
              Trabajar con JSONP
            </h2>
            <p>
              En los &uacute;ltimos tiempos, la introducci&oacute;n de JSONP, ha permitido la creaci&oacute;n de aplicaciones h&iacute;bridas de contenidos. Muchos sitios importantes ofrecen JSONP como servicio de informaci&oacute;n, el cual se accede a trav&eacute;s de una API (en ingl&eacute;s <em>Application programming interface</em>) predefinida. Un servicio particular que permite obtener informaci&oacute;n en formato JSONP es <a href="http://developer.yahoo.com/yql/console/">Yahoo! Query Language</a>, el cual se utiliza a continuaci&oacute;n para obtener, por ejemplo, noticias sobre gatos:
            </p>
            <div class="example">
              <p class="title">
                <b>Utilizar YQL y JSONP</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$.ajax({
    url : 'http://query.yahooapis.com/v1/public/yql',

    // se agrega como par&aacute;metro el nombre de la funci&oacute;n de devoluci&oacute;n,
    // seg&uacute;n se especifica en el servicio de YQL
    jsonp : 'callback',

    // se le indica a jQuery que se espera informaci&oacute;n en formato JSONP
    dataType : 'jsonp',

    // se le indica al servicio de YQL cual es la informaci&oacute;n que se desea y que se la quiere en formato JSON
    data : {
        q : 'select title,abstract,url from search.news where query="cat"',
        format : 'json'
    },

    // se ejecuta una funci&oacute;n al ser satisfactoria la petici&oacute;n
    success : function(response) {
        console.log(response);
    }
});
</pre>
              </div>
            </div>
            <p>
              jQuery se encarga de solucionar todos los aspectos complejos de la petici&oacute;n JSONP. Lo &uacute;nico que debe hacer es especificar el nombre de la funci&oacute;n de devoluci&oacute;n (en este caso "<em>callback</em>", seg&uacute;n lo especifica YQL) y el resultado final ser&aacute; como una petici&oacute;n Ajax normal.
            </p>
          </div>
          <div title="Eventos Ajax" class="section">
            <h2>
              Eventos Ajax
            </h2>
            <p>
              A menudo, querr&aacute; ejecutar una funci&oacute;n cuando una petici&oacute;n haya comenzado o terminado, como por ejemplo, mostrar o ocultar un indicador. En lugar de definir estas funciones dentro de cada petici&oacute;n, jQuery provee la posibilidad de vincular eventos Ajax a elementos seleccionados. Para una lista completa de eventos Ajax, puede consultar <a href="http://docs.jquery.com/Ajax_Events">http://docs.jquery.com/Ajax_Events</a>.
            </p>
            <div class="example">
              <p class="title">
                <b>Mostrar/Ocultar un indicador utilizando Eventos Ajax</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$('#loading_indicator')
    .ajaxStart(function() { $(this).show(); })
    .ajaxStop(function() { $(this).hide(); });
</pre>
              </div>
            </div>
          </div>
          <div title="Ejercicios" class="section">
            <h2>
              Ejercicios
            </h2>
            <div title="Load External Content" class="section">
                <h3>
                  Cargar Contenido Externo
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/load.js</code>. La tarea es cargar el contenido de un art&iacute;culo de blog cuando el usuario haga click en el t&iacute;tulo del &iacute;tem.
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>Crear un elementos <em>div</em> despu&eacute;s del titulo de cada titulo de art&iacute;culo de blog y guardar una referencia hacia ellos en el elemento de titulo utilizando <code>$.fn.data</code>.                  </li>
                  <li>Vincular un evento click al titulo, el cual utilizar&aacute; el m&eacute;todo <code>$.fn.load</code> para cargar en cada <em>div</em> creado el contenido apropiado desde el archivo <code class="filename">/exercises/data/blog.html</code>. No olvide de deshabilitar el comportamiento predeterminado del evento <em>click</em>.
                  </li>
                </ol>
              </div>
              <p>
                Notar que cada titulo de art&iacute;culo de blog en index.html incluye un enlace hacia el art&iacute;culo. Necesitar&aacute; aprovechar el atributo href de cada enlace para obtener el contenido propio de blog.html. Una vez obtenida el valor del atributo, puede utilizar la siguiente forma para procesar la informaci&oacute;n y convertirla en un selector para utilizar en conjunto con <code>$.fn.load</code>:
              </p>
              <pre class="brush: js">
var href = 'blog.html#post1';
var tempArray = href.split('#');
var id = '#' + tempArray[1];
</pre>
              <p>
                Recuerde utilizar <code>console.log</code> para asegurarse que esta realizando lo correcto.
              </p>
            </div>
            <div title="Cargar Contenido Utilizando JSON" class="section">
                <h3>
                  Cargar Contenido Utilizando JSON
                </h3>
               <p>
                Abra el archivo <code></code> en el navegador. Realice el ejericio utilizando el archivo <code class="filename">/exercises/js/specials.js</code>. La tarea es mostrar los detalles del usuario para un d&iacute;a determinado cuando se selecciona desde la lista desplegable.
              </p>
              <div class="orderedlist">
                <ol class="orderedlist">
                  <li>
                    <p>
                      A&ntilde;adir un elemento <em>div</em> despu&eacute;s del formulario que se encuentra dentro del elemento <em>#specials</em>; all&iacute; ser&aacute; el lugar en donde se colocar&aacute; la informaci&oacute;n a obtener.
                    </p>
                  </li>
                  <li>Vincular el evento <em>change</em> en el elemento <em>select</em>; cuando se realiza un cambio en la selecci&oacute;n, enviar una petici&oacute;n Ajax a <code class="filename">/exercises/data/specials.json</code>.
                  </li>
                  <li>Cuando la petici&oacute;n devuelve una respuesta, utilizar el valor seleccionado en el select (ayuda: <code>$.fn.val</code>) para buscar la informaci&oacute;n correspondiente en la respuesta JSON.
                  </li>
                  <li>
                    <p>
                      A&ntilde;adir alg&uacute;n HTML con la informaci&oacute;n obtenida en el <em>div</em> creado anteriormente.
                    </p>
                  </li>
                  <li>
                    <p>
                      Finalmente remover el bot&oacute;n <em>submit</em> del formulario.
                    </p>
                  </li>
                </ol>
              </div>
              <p>
                Notar que cada vez que la selecci&oacute;n cambia, se realiza una petici&oacute;n Ajax. ¿C&oacute;mo cambiar&iacute;a el c&oacute;digo para realizar solo una petici&oacute;n y guardar la informaci&oacute;n para aprovecharla cuando se vuelve a cambiar la opci&oacute;n seleccionada?
              </p>
            </div>
          </div>
        </div>        <div id="capitulo-8" title="Extensiones" class="chapter">
			<h2 class="title">Extensiones</h2>
          <div title="¿Qu&eacute; es una Extensi&oacute;n?" class="section">
            <h2>
              ¿Qu&eacute; es una Extensi&oacute;n?
            </h2>
            <p>
              Una extensi&oacute;n de jQuery es simplemente un nuevo m&eacute;todo que se utilizar&aacute; para extender el prototipo (<em>prototype</em>) del objeto jQuery. Cuando se extiende el prototipo, todos los objetos jQuery hereden los m&eacute;todos a&ntilde;adidos. Por lo tanto, cuando se realiza una llamada <code>jQuery()</code>, es creado un nuevo objeto jQuery con todos los m&eacute;todos heredados.
            </p>
            <p>
              El objetivo de una extensi&oacute;n es realizar una acci&oacute;n utilizando una colecci&oacute;n de elementos, de la misma forma que lo hacen, por ejemplo, los m&eacute;todos <code>fadeOut</code> o <code>addClass</code> de la biblioteca.
            </p>
            <p>
              Usted puede realizar sus propias extensiones y utilizarlas de forma privada en su proyecto o tambi&eacute;n puede publicarlas para que otras personas le saquen provecho.
            </p>
          </div>
          <div title="Crear una Extensi&oacute;n B&aacute;sica" class="section">
            <h2>
              Crear una Extensi&oacute;n B&aacute;sica
            </h2>
            <p>
              El c&oacute;digo para realizar una extensi&oacute;n b&aacute;sica es la siguiente:
            </p>
            <pre class="brush: js">
(function($){
    $.fn.myNewPlugin = function() {
        return this.each(function(){
            // realizar algo
        });
    };
}(jQuery));
</pre>
            <p>
              La extensi&oacute;n del prototipo del objeto jQuery ocurre en la siguiente l&iacute;nea:
            </p>
            <pre class="brush: js">
$.fn.myNewPlugin = function() { //...
</pre>
            <p>
              La cual es encerrada en una funci&oacute;n autoejecutable:
            </p>
            <pre class="brush: js">
(function($){
    //...
}(jQuery));
</pre>
            <p>
              Esta posee la ventaja de crear un alcance "privado", permitiendo utilizar el signo dolar sin tener la preocupaci&oacute;n de que otra biblioteca tambi&eacute;n este utilizando dicho signo.
            </p>
            <p>
              Por ahora, internamente la extensi&oacute;n queda:
            </p>
            <pre class="brush: js">
$.fn.myNewPlugin = function() {
    return this.each(function(){
        // realizar algo
    });
};
</pre>
            <p>
              Dentro de ella, la palabra clave <code>this</code> hace referencia al objeto jQuery en donde la extensi&oacute;n es llamada.
            </p>
            <pre class="brush: js">
var somejQueryObject = $('#something');

$.fn.myNewPlugin = function() {
    alert(this === somejQueryObject);
};

somejQueryObject.myNewPlugin(); // muestra un alerta con 'true'
</pre>
            <p>
              El objeto jQuery, normalmente, contendr&aacute; referencias a varios elementos DOM, es por ello que a menudo se los refiere como una colecci&oacute;n.
            </p>
            <p>
              Para interactuar con la colecci&oacute;n de elementos, es necesario realizar un bucle, el cual se logra f&aacute;cilmente con el m&eacute;todo <code>each()</code>:
            </p>
            <pre class="brush: js">
$.fn.myNewPlugin = function() {
    return this.each(function(){

    });
};
</pre>
            <p>
              Al igual que otros m&eacute;todos, <code>each()</code> devuelve un objeto jQuery, permitiendo utilizar el encadenado de m&eacute;todos (<code>$(...).css().attr()...</code>). Para no romper esta convenci&oacute;n, la extensi&oacute;n a crear deber&aacute; devolver el objeto <code>this</code>, para permitir seguir con el encadenamiento. A continuaci&oacute;n se muestra un peque&ntilde;o ejemplo:
            </p>
            <pre class="brush: js">
(function($){
    $.fn.showLinkLocation = function() {
        return this.filter('a').each(function(){
            $(this).append(
                ' (' + $(this).attr('href') + ')'
            );
        });
    };
}(jQuery));

// Ejemplo de utilizaci&oacute;n:
$('a').showLinkLocation();
</pre>
            <p>
              La extensi&oacute;n modificar&aacute; todos los enlaces dentro de la colecci&oacute;n de elementos y les a&ntilde;adir&aacute; el valor de su atributo <code>href</code> entre par&eacute;ntesis.
            </p>
            <pre class="brush: js">
&lt;!-- Antes que la extensi&oacute;n sea llamada: --&gt;
&lt;a href="page.html"&gt;Foo&lt;/a&gt;

&lt;!-- Despu&eacute;s que la extensi&oacute;n es llamada: --&gt;
&lt;a href="page.html"&gt;Foo (page.html)&lt;/a&gt;
</pre>
            <p>
              Tambi&eacute;n es posible optimizar la extensi&oacute;n:
            </p>
            <pre class="brush: js">
(function($){
    $.fn.showLinkLocation = function() {
        return this.filter('a').append(function(){
              return ' (' + this.href + ')';
        });
    };
}(jQuery));
</pre>
            <p>
              El m&eacute;todo <code>append</code> permite especificar una funci&oacute;n de devoluci&oacute;n de llamada, y el valor devuelto determinar&aacute; que es lo que se a&ntilde;adir&aacute; a cada elemento. Note tambi&eacute;n que no se utiliza el m&eacute;todo <code>attr</code>, debido a que la API nativa del DOM permite un f&aacute;cil acceso a la propiedad <code>href</code>.
            </p>
            <p>
              A continuaci&oacute;n se muestra otro ejemplo de extensi&oacute;n. En este caso, no se requiere realizar un bucle en cada elemento ya que se delega la funcionalidad directamente en otro m&eacute;todo jQuery:
            </p>
            <pre class="brush: js">
(function($){
    $.fn.fadeInAndAddClass = function(duration, className) {
        return this.fadeIn(duration, function(){
            $(this).addClass(className);
        });
    };
}(jQuery));

// Ejemplo de utilizaci&oacute;n:
$('a').fadeInAndAddClass(400, 'finishedFading');
</pre>
          </div>
          <div title="Encontrar y Evaluar Extensiones" class="section">
            <h2>
              Encontrar y Evaluar Extensiones
            </h2>
            <p>
              Uno de los aspectos m&aacute;s populares de jQuery es la diversidad de extensiones que existen.
            </p>
            <p>
              Sin embargo, la calidad entre extensiones puede variar enormemente. Muchas son intensivamente probadas y bien mantenidas, pero otras son creadas de forma apresurada y luego ignoradas, sin seguir buenas pr&aacute;cticas.
            </p>
            <p>
              Google es la mejor herramienta para encontrar extensiones (aunque el equipo de jQuery este trabajando para mejorar su repositorio de extensiones). Una vez encontrada la extensi&oacute;n, posiblemente quiera consultar la lista de correos de jQuery o el canal IRC #jquery para obtener la opini&oacute;n de otras personas sobre dicha extensi&oacute;n.
            </p>
            <p>
              Aseg&uacute;rese que la extensi&oacute;n este bien documentada, y que se ofrecen ejemplos de su utilizaci&oacute;n. Tambi&eacute;n tenga cuidado con las extensiones que realizan m&aacute;s de lo que necesita, estas pueden llegar a sobrecargar su p&aacute;gina. Para m&aacute;s consejos sobre como detectar una extensi&oacute;n mediocre, puede leer el art&iacute;culo (en ingl&eacute;s) <a href="http://remysharp.com/2010/06/03/signs-of-a-poorly-written-jquery-plugin/">Signs of a poorly written jQuery plugin</a> por Remy Sharp.
            </p>
            <p>
              Una vez seleccionada la extensi&oacute;n, necesitar&aacute; a&ntilde;adirla a su p&aacute;gina. Primero, descargue la extensi&oacute;n, descomprimala (si es necesario) y mu&eacute;vala a la carpeta de su aplicaci&oacute;n. Finalmente insertela utilizando el elemento script (luego de la inclusi&oacute;n de jQuery).
            </p>
          </div>
          <div title="Escribir Extensiones" class="section">
            <h2>
              Escribir Extensiones
            </h2>
            <p>
              A veces, desee realizar una funcionalidad disponible en todo el c&oacute;digo, por ejemplo, un m&eacute;todo que pueda ser llamado desde una selecci&oacute;n el cual realice una serie de operaciones.
            </p>
            <p>
              La mayor&iacute;a de las extensiones son m&eacute;todos creados dentro del espacio de nombres <code>$.fn</code>. jQuery garantiza que un m&eacute;todo llamado sobre el objeto jQuery sea capaz de acceder a dicho objeto a trav&eacute;s de <code>this</code>. En contrapartida, la extensi&oacute;n debe garantizar de devolver el mismo objeto recibido (a menos que se explicite lo contrario).
            </p>
            <p>
              A continuaci&oacute;n se muestra un ejemplo:
            </p>
            <div class="example">
              <p class="title">
                <b>Crear una extensi&oacute;n para a&ntilde;adir y remover una clase en un elemento al suceder el evento hover</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
// definici&oacute;n de la extensi&oacute;n
(function($){
    $.fn.hoverClass = function(c) {
        return this.hover(
            function() { $(this).toggleClass(c); }
        );
    };
})(jQuery);

// utilizar la extensi&oacute;n
$('li').hoverClass('hover');
</pre>
              </div>
            </div>
            <p>
              Para m&aacute;s informaci&oacute;n sobre el desarrollo de extensiones, puede consultar el art&iacute;culo (en ingl&eacute;s) <a href="http://www.learningjquery.com/2007/10/a-plugin-development-pattern">A Plugin Development Pattern</a> de Mike Alsup. En dicho art&iacute;culo, se desarrolla una extensi&oacute;n llamada <code>$.fn.hilight</code>, la cual provee soporte para la extensi&oacute;n <a href="http://plugins.jquery.com/project/metadata">metadata</a> (en caso de estar presente) y provee un m&eacute;todo descentralizado para establecer opciones globales o de instancias de la extensi&oacute;n.
            </p>
            <div class="example">
              <p class="title">
                <b>El patr&oacute;n de desarrollo de extensiones para jQuery explicado por Mike Alsup</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
//
// crear una clausura
//
(function($) {
  //
  // definici&oacute;n de la extensi&oacute;n
  //
  $.fn.hilight = function(options) {
    debug(this);
    // generaci&oacute;n de las opciones principales antes de interactuar
    var opts = $.extend({}, $.fn.hilight.defaults, options);
    // se iteractua y formatea cada elemento
    return this.each(function() {
      $this = $(this);
      // generaci&oacute;n de las opciones especificas de cada elemento
      var o = $.meta ? $.extend({}, opts, $this.data()) : opts;
      // actualizaci&oacute;n de los estilos de cada elemento
      $this.css({
        backgroundColor: o.background,
        color: o.foreground
      });
      var markup = $this.html();
      // se llama a la funci&oacute;n de formateo
      markup = $.fn.hilight.format(markup);
      $this.html(markup);
    });
  };
  //
  // funci&oacute;n privada para realizar depuraci&oacute;n
  //
  function debug($obj) {
    if (window.console &amp;&amp; window.console.log)
      window.console.log('hilight selection count: ' + $obj.size());
  };
  //
  // definir y exponer la funci&oacute;n de formateo
  //
  $.fn.hilight.format = function(txt) {
    return '&lt;strong&gt;' + txt + '&lt;/strong&gt;';
  };
  //
  // opciones predeterminadas
  //
  $.fn.hilight.defaults = {
    foreground: 'red',
    background: 'yellow'
  };
//
// fin de la clausura
//
})(jQuery);
</pre>
              </div>
            </div>
          </div>
          <h2>
            Escribir Extensiones con Mantenimiento de Estado Utilizando Widget Factory de jQuery UI
          </h2>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Esta secci&oacute;n esta basada, con permiso del autor, en el art&iacute;culo <a href="http://blog.nemikor.com/2010/05/15/building-stateful-jquery-plugins/">Building Stateful jQuery Plugins</a> de Scott Gonzalez.
          </p>
          </div>
          <p>
            Mientras que la mayor&iacute;a de las extensiones para jQuery son sin mantenimiento de estado (en ingl&eacute;s <em>stateless</em>) — es decir, extensiones que se ejecutan solamente sobre un elemento, siendo esa su &uacute;nica interacci&oacute;n — existe un gran conjunto de funcionalidades que no se aprovechan en el patr&oacute;n b&aacute;sico con que se desarrollan las extensiones.
          </p>
          <p>
            Con el fin de llenar ese vac&iacute;o, jQuery UI (<a href="http://jqueryui.com/">jQuery User Interface</a>) ha implementado un sistema m&aacute;s avanzado de extensiones. Este sistema permite manejar estados y admite m&uacute;ltiples funciones para ser expuestas en una &uacute;nica extensi&oacute;n. Dicho sistema es llamado <em>widget factory</em> y forma parte de la versi&oacute;n 1.8 de jQuery UI a trav&eacute;s de <code>jQuery.widget</code>, aunque tambi&eacute;n puede ser utilizado sin depender de jQuery UI.
          </p>
          <p>
            Para demostrar las capacidades de <em>widget factory</em>, se crear&aacute; una extensi&oacute;n que tendr&aacute; como funcionalidad ser una barra de progreso.
          </p>
          <p>
            Por ahora, la extensi&oacute;n solo permitir&aacute; establecer el valor de la barra de progreso una sola vez. Esto se realizar&aacute; llamando a <code>jQuery.widget</code> con dos par&aacute;metros: el nombre de la extensi&oacute;n a crear y un objeto literal que contendr&aacute; las funciones soportadas por la extensi&oacute;n. Cuando la extensi&oacute;n es llamada, una instancia de ella es creada y todas las funciones se ejecutaran en el contexto de esa instancia.
          </p>
          <p>
            Existen dos importantes diferencias en comparaci&oacute;n con una extensi&oacute;n est&aacute;ndar de jQuery: En primer lugar, el contexto es un objeto, no un elemento DOM. En segundo lugar, el contexto siempre es un &uacute;nico objeto, nunca una colecci&oacute;n.
          </p>
          <div class="example">
            <p class="title">
              <b>Una simple extensi&oacute;n con mantenimiento de estado utilizando widget factory de jQuery UI</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$.widget("nmk.progressbar", {
    _create: function() {
        var progress = this.options.value + "%";
        this.element
            .addClass("progressbar")
            .text(progress);
    }
});
</pre>
            </div>
          </div>
          <p>
            El nombre de la extensi&oacute;n debe contener un espacio de nombres, en este caso se utiliza <code>nmk</code>. Los espacios de nombres tienen una limitaci&oacute;n de un solo nivel de profundidad — es decir que por ejemplo, no es posible utilizar <code>nmk.foo</code>. Como se puede ver en el ejemplo, <em>widget factory</em> provee dos propiedades para ser utilizadas. La primera, <code>this.element</code> es un objeto jQuery que contiene exactamente un elemento. En caso que la extensi&oacute;n sea ejecutada en m&aacute;s de un elemento, una instancia separada de la extensi&oacute;n ser&aacute; creada por cada elemento y cada una tendr&aacute; su propio <code>this.element</code>. La segunda propiedad, <code>this.options</code>, es un conjunto de pares clave/valor con todas las opciones de la extensi&oacute;n. Estas opciones pueden pasarse a la extensi&oacute;n como se muestra a continuaci&oacute;n:
          </p>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Cuando est&eacute; realizando sus propias extensiones es recomendable utilizar su propio espacio de nombres, ya que deja en claro de donde proviene la extensi&oacute;n y si es parte de una colecci&oacute;n mayor. Por otro lado, el espacio de nombres <code>ui</code> est&aacute; reservado para las extensiones oficiales de jQuery UI.
          </p>
          </div>
          <div class="example">
            <p class="title">
              <b>Pasar opciones al widget</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$("&lt;div&gt;&lt;/div&gt;")
    .appendTo( "body" )
    .progressbar({ value: 20 });
</pre>
            </div>
          </div>
          <p>
            Cuando se llama a <code>jQuery.widget</code> se extiende a jQuery a&ntilde;adiendo el m&eacute;todo a <code>jQuery.fn</code> (de la misma forma que cuando se crea una extensi&oacute;n est&aacute;ndar). El nombre de la funci&oacute;n que se a&ntilde;ade esta basado en el nombre que se pasa a <code>jQuery.widget</code>, sin el espacio de nombres (en este caso el nombre ser&aacute; <code>jQuery.fn.progressbar</code>).
          </p>
          <p>
            Como se muestra a continuaci&oacute;n, es posible especificar valores predeterminados para cualquier opci&oacute;n. Estos valores deber&iacute;an basarse en la utilizaci&oacute;n m&aacute;s com&uacute;n de la extensi&oacute;n.
          </p>
          <div class="example">
            <p class="title">
              <b>Establecer opciones predeterminadas para un widget</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$.widget("nmk.progressbar", {
    // opciones predeterminadas
    options: {
        value: 0
    },

    _create: function() {
        var progress = this.options.value + "%";
        this.element
            .addClass( "progressbar" )
            .text( progress );
    }
});
</pre>
            </div>
          </div>
            <h3>
              A&ntilde;adir M&eacute;todos a un Widget
            </h3>
          <p>
            Ahora que es posible inicializar la extensi&oacute;n, es necesario a&ntilde;adir la habilidad de realizar acciones a trav&eacute;s de m&eacute;todos definidos en la extensi&oacute;n. Para definir un m&eacute;todo en la extensi&oacute;n es necesario incluir la funci&oacute;n en el objeto literal que se pasa a <code>jQuery.widget</code>. Tambi&eacute;n es posible definir m&eacute;todos "privados" anteponiendo un gui&oacute;n bajo al nombre de la funci&oacute;n.
          </p>
          <div class="example">
            <p class="title">
              <b>Crear m&eacute;todos en el Widget</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
$.widget("nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        var progress = this.options.value + "%";
        this.element
            .addClass("progressbar")
            .text(progress);
    },

    // crear un m&eacute;todo p&uacute;blico
    value: function(value) {
        // no se pasa ning&uacute;n valor, entonces act&uacute;a como m&eacute;todo obtenedor
        if (value === undefined) {
            return this.options.value;
        // se pasa un valor, entonces act&uacute;a como m&eacute;todo establecedor
        } else {
            this.options.value = this._constrain(value);
            var progress = this.options.value + "%";
            this.element.text(progress);
        }
    },

    // crear un m&eacute;todo privado
    _constrain: function(value) {
        if (value &gt; 100) {
            value = 100;
        }
        if (value &lt; 0) {
            value = 0;
        }
        return value;
    }
});
</pre>
            </div>
          </div>
          <p>
            Para llamar a un m&eacute;todo en una instancia de la extensi&oacute;n, se debe pasar el nombre de dicho m&eacute;todo a la extensi&oacute;n. En caso que se llame a un m&eacute;todo que acepta par&aacute;metros, estos se deben pasar a continuaci&oacute;n del nombre del m&eacute;todo.
          </p>
          <div class="example">
            <p class="title">
              <b>Llamar a m&eacute;todos en una instancia de extensi&oacute;n</b>
            </p>
            <div class="example-contents">
              <pre class="brush: js">
var bar = $("&lt;div&gt;&lt;/div&gt;")
    .appendTo("body")
    .progressbar({ value: 20 });

// obtiene el valor actual
alert(bar.progressbar("value"));

// actualiza el valor
bar.progressbar("value", 50);

// obtiene el valor nuevamente
alert(bar.progressbar("value"));
</pre>
            </div>
          </div>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Ejecutar m&eacute;todos pasando el nombre del m&eacute;todo a la misma funci&oacute;n jQuery que se utiliza para inicializar la extensi&oacute;n puede parecer extra&ntilde;o, sin embargo es realizado as&iacute; para prevenir la "contaminaci&oacute;n" del espacio de nombres de jQuery manteniendo al mismo tiempo la capacidad de llamar a m&eacute;todos en cadena.
          </p>
          </div>
          <div title="Trabajar con las Opciones del Widget" class="section">
              <h3>
                Trabajar con las Opciones del Widget
              </h3>
            <p>
              Uno de los m&eacute;todos disponibles autom&aacute;ticamente para la extensi&oacute;n es <code>option</code>. Este m&eacute;todo permite obtener y establecer opciones despu&eacute;s de la inicializaci&oacute;n y funciona exactamente igual que los m&eacute;todos <em>attr</em> y <em>css</em> de jQuery: pasando &uacute;nicamente un nombre como argumento el m&eacute;todo funciona como obtenedor, mientras que pasando uno o m&aacute;s conjuntos de nombres y valores el m&eacute;todo funciona como establecedor. Cuando es utilizado como m&eacute;todo obtenedor, la extensi&oacute;n devolver&aacute; el valor actual de la opci&oacute;n correspondiente al nombre pasado como argumento. Por otro lado, cuando es utilizado como un m&eacute;todo establecedor, el m&eacute;todo <code>_setOption</code> de la extensi&oacute;n ser&aacute; llamado por cada opci&oacute;n que se desea establecer.
            </p>
            <div class="example">
              <p class="title">
                <b>Responder cuando una opci&oacute;n es establecida</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$.widget("nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        this.element.addClass("progressbar");
        this._update();
    },

    _setOption: function(key, value) {
        this.options[key] = value;
        this._update();
    },

    _update: function() {
        var progress = this.options.value + "%";
        this.element.text(progress);
    }
});
</pre>
              </div>
            </div>
          </div>
          <div title="A&ntilde;adir Funciones de Devoluci&oacute;n de Llamada" class="section">
              <h3>
                A&ntilde;adir Funciones de Devoluci&oacute;n de Llamada
              </h3>
            <p>
              Uno de las maneras m&aacute;s f&aacute;ciles de extender una extensi&oacute;n es a&ntilde;adir funciones de devoluci&oacute;n de llamada, para que de esta forma el usuario puede reaccionar cuando el estado de la extensi&oacute;n cambie. A continuaci&oacute;n se mostrar&aacute; como a&ntilde;adir una funci&oacute;n de devoluci&oacute;n de llamada a la extensi&oacute;n creada para indicar cuando la barra de progreso haya alcanzado el 100%. El m&eacute;todo <code>_trigger</code> obtiene tres par&aacute;metros: el nombre de la funci&oacute;n de devoluci&oacute;n, el objeto de evento nativo que inicializa la funci&oacute;n de devoluci&oacute;n y un conjunto de informaci&oacute;n relevante al evento. El nombre de la funci&oacute;n de devoluci&oacute;n es el &uacute;nico par&aacute;metro obligatorio, pero los otros pueden ser muy &uacute;tiles si el usuario desea implementar funcionalidades personalizadas.
            </p>
            <div class="example">
              <p class="title">
                <b>Proveer funciones de devoluci&oacute;n de llamada</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$.widget("nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        this.element.addClass("progressbar");
        this._update();
    },

    _setOption: function(key, value) {
        this.options[key] = value;
        this._update();
    },

    _update: function() {
        var progress = this.options.value + "%";
        this.element.text(progress);
        if (this.options.value == 100) {
            this._trigger("complete", null, { value: 100 });
        }
    }
});
</pre>
              </div>
            </div>
            <p>
              Las funciones de devoluci&oacute;n son esencialmente s&oacute;lo opciones adicionales, por lo cual, pueden ser establecidas como cualquier otra opci&oacute;n. Cada vez que una funci&oacute;n de devoluci&oacute;n es ejecutada, un evento correspondiente se activa tambi&eacute;n. El tipo de evento se determina mediante la concatenaci&oacute;n del nombre de la extensi&oacute;n y el nombre de la funci&oacute;n de devoluci&oacute;n. Dicha funci&oacute;n y evento reciben dos mismos par&aacute;metros: un objeto de evento y un conjunto de informaci&oacute;n relevante al evento.
            </p>
            <p>
              Si la extensi&oacute;n tendr&aacute; alguna funcionalidad que podr&aacute; ser cancelada por el usuario, la mejor manera de hacerlo es creando funciones de devoluci&oacute;n cancelables. El usuario podr&aacute; cancelar una funci&oacute;n de devoluci&oacute;n o su evento asociado de la misma manera que se cancela cualquier evento nativo: llamando a <code>event.preventDefault()</code> o utilizando <code>return false</code>.
            </p>
            <div class="example">
              <p class="title">
                <b>Vincular a eventos del widget</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
var bar = $("&lt;div&gt;&lt;/div&gt;")
    .appendTo("body")
    .progressbar({
        complete: function(event, data) {
            alert( "Funci&oacute;n de devoluci&oacute;n" );
        }
    })
    .bind("progressbarcomplete", function(event, data) {
        alert("El valor de la barra de progreso es " + data.value);
    });

bar.progressbar("option", "value", 100);
</pre>
              </div>
            </div>
            <div title="En profundidad: Widget Factory" class="sidebar">
              <p class="title">
                <b>En profundidad: Widget Factory</b>
              </p>
              <p>
                Cuando se llama a <code>jQuery.widget</code>, &eacute;sta crea una funci&oacute;n constructora para la extensi&oacute;n y establece el objeto literal que se pasa como el prototipo para todas las instancias de la extensi&oacute;n. Todas las funcionalidades que autom&aacute;ticamente se a&ntilde;aden a la extensi&oacute;n provienen del prototipo base del widget, el cual es definido como <code>jQuery.Widget.prototype</code>. Cuando una instancia de la extensi&oacute;n es creada, es guardada en el elemento DOM original utilizando <code>jQuery.data</code>, con el nombre de la extensi&oacute;n como palabra clave.
              </p>
              <p>
                Debido a que la instancia de la extensi&oacute;n esta directamente vinculada al elemento DOM, es posible acceder a la instancia de la extensi&oacute;n de forma directa. Esto permite llamar a m&eacute;todos directamente en la instancia de la extensi&oacute;n en lugar de pasar el nombre del m&eacute;todo como una cadena de caracteres, dando la posibilidad de acceder a las propiedades de la extensi&oacute;n.
              </p>
              <pre class="brush: js">
var bar = $("&lt;div&gt;&lt;/div&gt;")
    .appendTo("body")
    .progressbar()
    .data("progressbar" );

// llamar a un m&eacute;todo directamente en la instancia de la extensi&oacute;n
bar.option("value", 50);

// acceder a propiedades en la instancia de la extensi&oacute;n
alert(bar.options.value);
</pre>
              <p>
                Uno de los mayores beneficios de tener un constructor y un prototipo para una extensi&oacute;n es la facilidad de extender la extensi&oacute;n. El hecho de a&ntilde;adir o cambiar m&eacute;todos en el prototipo de la extensi&oacute;n, permite tambi&eacute;n modificarlos en todas las instancias de la extensi&oacute;n. Por ejemplo, si deseamos a&ntilde;adir un m&eacute;todo a la extensi&oacute;n de barra de progreso para permitir restablecer el progreso a 0%, es posible hacerlo a&ntilde;adiendo este m&eacute;todo al prototipo y autom&aacute;ticamente estar&aacute; disponible para ser llamada desde cualquier instancia de la extensi&oacute;n.
              </p>
              <pre class="brush: js">
$.nmk.progressbar.prototype.reset = function() {
    this._setOption("value", 0);
};
</pre>
            </div>
          </div>
          <div title="Limpieza" class="section">
              <h3>
                Limpieza
              </h3>
            <p>
              En algunos casos, tendr&aacute; sentido permitir a los usuarios aplicar y desaplicar la extensi&oacute;n. Esto es posible hacerlo a trav&eacute;s del m&eacute;todo <code>destroy</code>. Con dicho m&eacute;todo, es posible deshacer todo lo realizado con la extensi&oacute;n. Tambi&eacute;n &eacute;ste es llamado autom&aacute;ticamente si el elemento vinculado a la extensi&oacute;n es eliminado del DOM (por lo cual tambi&eacute;n es posible utilizarlo para la "recolecci&oacute;n de basura"). El m&eacute;todo <code>destroy</code> predeterminado remueve el v&iacute;nculo entre el elemento DOM y la instancia de la extensi&oacute;n
            </p>
            <div class="example">
              <p class="title">
                <b>A&ntilde;adir un m&eacute;todo destroy al widget</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
$.widget( "nmk.progressbar", {
    options: {
        value: 0
    },

    _create: function() {
        this.element.addClass("progressbar");
        this._update();
    },

    _setOption: function(key, value) {
        this.options[key] = value;
        this._update();
    },

    _update: function() {
        var progress = this.options.value + "%";
        this.element.text(progress);
        if (this.options.value == 100 ) {
            this._trigger("complete", null, { value: 100 });
        }
    },

    destroy: function() {
        this.element
            .removeClass("progressbar")
            .text("");

        // llama a la funci&oacute;n base destroy
        $.Widget.prototype.destroy.call(this);
    }
});
</pre>
              </div>
            </div>
          </div>
          <div title="Conclusi&oacute;n" class="section">
              <h3>
                Conclusi&oacute;n
              </h3>
            <p>
              La utilizaci&oacute;n de <em>Widget factory</em> es solo una manera de crear extensiones con mantenimiento de estado. Existen algunos modelos diferentes que pueden ser utilizados y cada uno posee sus ventajas y desventajas. <em>Widget factory</em> resuelve muchos problemas comunes, mejora significativamente la productividad y la reutilizaci&oacute;n de c&oacute;digo.
            </p>
          </div>
          <div title="Ejercicios" class="section">
            <h2>
              Ejercicios
            </h2>
            <div title="Realizar una Tabla Ordenable" class="section">
                <h3>
                  Realizar una Tabla Ordenable
                </h3>
              <p>
                Para este ejercicio, la tarea es identificar, descargar e implementar una extensi&oacute;n que permita ordenar la tabla existente en la p&aacute;gina index.html. Cuando esté listo, todas las columnas de la tabla deben poder ser ordenables.
              </p>
            </div>
            <div title="Escribir una Extensi&oacute;n Para Cambiar el Color de Fondo en Tablas" class="section">
                <h3>
                  Escribir una Extensi&oacute;n Para Cambiar el Color de Fondo en Tablas
                </h3>
              <p>
                Abra el archivo <code></code> en el navegador. Realice el ejercicio utilizando el archivo <code class="filename">/exercises/js/stripe.js</code>. La tarea es escribir una extensi&oacute;n llamada "stripe" la cual podr&aacute; ser llamada desde cualquier elemento table y deber&aacute; cambiar el color de fondo de las filas impares en el cuerpo de la tabla. El color podr&aacute; ser especificado como par&aacute;metro de la extensi&oacute;n.
              </p>
              <pre class="brush: js">
$('#myTable').stripe('#cccccc');
</pre>
              <p>
                No olvide de devolver la tabla para que otros m&eacute;todos puedan ser encadenados luego de la llamada a la extensi&oacute;n.
              </p>
            </div>
          </div>
        </div> 
      </div>   <div title="Parte&nbsp;III.&nbsp;Temas Avanzados">
	  <h1 class="title">Parte&nbsp;III.&nbsp;Temas Avanzados</h1>
	  
	<div title="Esta secci&oacute;n est&aacute; en progreso" class="article">
	<h2 class="title">Esta secci&oacute;n est&aacute; en progreso</h2>
	<hr/>
	  <p>
		Si desea contribuir con esta secci&oacute;n, por favor visite <a href="https://github.com/dzignus/jqfundamentals">https://github.com/dzignus/jqfundamentals</a>.
	  </p>
	</div>
	         <div id="capitulo-9" title="Mejores Pr&aacute;cticas para Aumentar el Rendimiento" class="chapter">
			<h2 class="title">Mejores Pr&aacute;cticas para Aumentar el Rendimiento</h2>
          <p>
            Este cap&iacute;tulo cubre numerosas mejores pr&aacute;cticas de JavaScript y jQuery, sin un orden en particular. Muchas de estas pr&aacute;cticas est&aacute;n basadas en la presentaci&oacute;n <a href="http://paulirish.com/perf">jQuery Anti-Patterns for Performance</a> (en ingl&eacute;s) de Paul Irish.
          </p>
          <div title="Guardar la Longitud en Bucles" class="section">
                  <h2>
                    Guardar la Longitud en Bucles
                  </h2>
            <p>
              En un bucle, no es necesario acceder a la longitud de un arreglo cada vez que se eval&uacute;a la condici&oacute;n; dicho valor se puede guardar previamente en una variable.
            </p>
            <pre class="brush: js">
var myLength = myArray.length;

for (var i = 0; i &lt; myLength; i++) {
    // do stuff
}
</pre>
          </div>
          <div title="A&ntilde;adir Nuevo Contenido por Fuera de un Bucle" class="section">
                  <h2>
                    A&ntilde;adir Nuevo Contenido por Fuera de un Bucle
                  </h2>
            <p>
              Si va a insertar muchos elementos en el DOM, h&aacute;galo todo de una sola vez, no de una por vez.
            </p>
            <pre class="brush: js">
// mal
$.each(myArray, function(i, item) {
   var newListItem = '&lt;li&gt;' + item + '&lt;/li&gt;';
   $('#ballers').append(newListItem);
});

// mejor: realizar esto
var frag = document.createDocumentFragment();

$.each(myArray, function(i, item) {
    var newListItem = '&lt;li&gt;' + item + '&lt;/li&gt;';
    frag.appendChild(newListItem);
});
$('#ballers')[0].appendChild(frag);

// o esto:
var myHtml = '';

$.each(myArray, function(i, item) {
    myHtml += '&lt;li&gt;' + item + '&lt;/li&gt;';
});
$('#ballers').html(myHtml);
</pre>
          </div>
          <div title="No Repetirse" class="section">
                  <h2>
                    No Repetirse
                  </h2>
            <p>
              No se repita; realice las cosas una vez y s&oacute;lo una, caso contrario lo estar&aacute; haciendo mal.
            </p>
            <pre class="brush: js">
// MAL
if ($eventfade.data('currently') != 'showing') {
    $eventfade.stop();
}

if ($eventhover.data('currently') != 'showing') {
    $eventhover.stop();
}

if ($spans.data('currently') != 'showing') {
    $spans.stop();
}

// BIEN
var $elems = [$eventfade, $eventhover, $spans];
$.each($elems, function(i,elem) {
    if (elem.data('currently') != 'showing') {
        elem.stop();
    }
});
</pre>
          </div>
          <div title="Cuidado con las Funciones An&oacute;nimas" class="section">
                  <h2>
                    Cuidado con las Funciones An&oacute;nimas
                  </h2>
            <p>
              No es aconsejable utilizar de sobremanera las funciones an&oacute;nimas. Estas son dif&iacute;ciles de depurar, mantener, probar o reutilizar. En su lugar, utilice un objeto literal para organizar y nombrar sus controladores y funciones de devoluci&oacute;n de llamada.
            </p>
            <pre class="brush: js">
// MAL
$(document).ready(function() {
    $('#magic').click(function(e) {
        $('#yayeffects').slideUp(function() {
            // ...
        });
    });

    $('#happiness').load(url + ' #unicorns', function() {
        // ...
    });
});

// MEJOR
var PI = {
    onReady : function() {
        $('#magic').click(PI.candyMtn);
        $('#happiness').load(PI.url + ' #unicorns', PI.unicornCb);
    },

    candyMtn : function(e) {
        $('#yayeffects').slideUp(PI.slideCb);
    },

    slideCb : function() { ... },

    unicornCb : function() { ... }
};

$(document).ready(PI.onReady);
</pre>
          </div>
          <div title="Optimizaci&oacute;n de Selectores" class="section">
                  <h2>
                    Optimizaci&oacute;n de Selectores
                  </h2>
            <p>
              La optimizaci&oacute;n de selectores es menos importante de lo que sol&iacute;a ser, debido a la implementaci&oacute;n en algunos navegadores de <code>document.querySelectorAll()</code>, pasando la carga de jQuery hacia el navegador. Sin embargo, existen algunos consejos que debe tener en cuenta.
            </p>
            <div title="Selectores basados en ID" class="sect2">
                <h3>
                  Selectores basados en ID
                </h3>
              <p>
                Siempre es mejor comenzar las selecciones con un ID.
              </p>
              <pre class="brush: js">
// r&aacute;pido
$('#container div.robotarm');

// super-r&aacute;pido
$('#container').find('div.robotarm');
</pre>
              <p>
                El ejemplo que utiliza <code>$.fn.find</code> es m&aacute;s r&aacute;pido debido a que la primera selecci&oacute;n utiliza el motor de selecci&oacute;n interno <a href="http://sizzlejs.com/">Sizzle</a> — mientras que la selecci&oacute;n realizada &uacute;nicamente por ID utiliza <code>document.getElementById()</code>(), el cual es extremadamente r&aacute;pido debido a que es una funci&oacute;n nativa del navegador.
              </p>
            </div>
            <div title="Especificidad" class="sect2">
                <h3>
                  Especificidad
                </h3>
              <p>
                Trate de ser especifico para el lado derecho de la selecci&oacute;n y menos especifico para el izquierdo.
              </p>
              <pre class="brush: js">
// no optimizado
$('div.data .gonzalez');

// optimizado
$('.data td.gonzalez');
</pre>
              <p>
                Use en lo posible <code>etiqueta.clase</code> del lado derecho de la selecci&oacute;n, y solo <code>etiqueta</code> &oacute; <code>.clase</code> en la parte izquierda.
              </p>
              <p>
                Evite especificidad excesiva.
              </p>
              <pre class="brush: js">
$('.data table.attendees td.gonzalez');

// mucho mejor: eliminar la parte media de ser posible
$('.data td.gonzalez');
</pre>
              <p>
                La segunda selecci&oacute;n tiene mejor rendimiento debido a que atraviesa menos capas para buscar el elemento.
              </p>
            </div>
            <div title="Evitar el Selector Universal" class="sect2">
                <h3>
                  Evitar el Selector Universal
                </h3>
              <p>
                Selecciones en donde se especifica de forma impl&iacute;cita o explicita una selecci&oacute;n universal puede resultar muy lento.
              </p>
              <pre class="brush: js">
$('.buttons &gt; *');      // muy lento
$('.buttons').children();  // mucho mejor

$('.gender :radio');       // selecci&oacute;n universal impl&iacute;cita
$('.gender *:radio');      // misma forma, pero de forma expl&iacute;cita
$('.gender input:radio');  // mucho mejor
</pre>
            </div>
          </div>
          <div title="Utilizar la Delegaci&oacute;n de Eventos" class="section">
                  <h2>
                    Utilizar la Delegaci&oacute;n de Eventos
                  </h2>
            <p>
              La delegaci&oacute;n de eventos permite vincular un controlador de evento a un elemento contenedor (por ejemplo, una lista desordenada) en lugar de m&uacute;ltiples elementos contenidos (por ejemplo, los &iacute;tems de una lista). jQuery realiza este trabajo f&aacute;cil a trav&eacute;s de <code>$.fn.live</code> y <code>$.fn.delegate</code>. En lo posible, es recomendable utilizar $.fn.delegate en lugar de <code>$.fn.live</code>, ya que elimina la necesidad de una selecci&oacute;n y su contexto explicito reduce la carga en aproximadamente un 80%.
            </p>
            <p>
              Adem&aacute;s, la delegaci&oacute;n de eventos permite a&ntilde;adir nuevos elementos contenedores a la p&aacute;gina sin tener que volver a vincular sus controladores de eventos.
            </p>
            <pre class="brush: js">
// mal (si existen muchos items en la lista)
$('li.trigger').click(handlerFn);

// mejor: delegaci&oacute;n de eventos con $.fn.live
$('li.trigger').live('click', handlerFn);

// mucho mejor: delegaci&oacute;n de eventos con $.fn.delegate
// permite especificar un contexto de forma f&aacute;cil
$('#myList').delegate('li.trigger', 'click', handlerFn);
</pre>
          </div>
          <div title="Separar Elementos para Trabajar con Ellos" class="section">
                  <h2>
                    Separar Elementos para Trabajar con Ellos
                  </h2>
                </div>
            <p>
              En lo posible, hay que evitar la manipulaci&oacute;n del DOM. Para ayudar con este prop&oacute;sito, a partir de la versi&oacute;n 1.4, jQuery introduce <code>$.fn.detach</code> el cual permite trabajar elementos de forma separada del DOM para luego insertarlos.
            </p>
            <pre class="brush: js">
var $table = $('#myTable');
var $parent = $table.parent();

$table.detach();
// ... se a&ntilde;aden muchas celdas a la tabla
$parent.append(table);
</pre>
          </div>
          <div title="Utilizar Estilos en Cascada para Cambios de CSS en Varios Elementos" class="section">
                  <h2>
                    Utilizar Estilos en Cascada para Cambios de CSS en Varios Elementos
                  </h2>
            <p>
              Si va a cambiar el CSS en m&aacute;s de 20 elementos utilizando <code>$.fn.css</code>, considere realizar los cambios de estilos a&ntilde;adi&eacute;ndolos en una etiqueta <em>style</em>. De esta forma se incrementa un 60% el rendimiento.
            </p>
            <pre class="brush: js">
// correcto hasta 20 elementos, lento en m&aacute;s elementos
$('a.swedberg').css('color', '#asd123');
$('&lt;style type="text/css"&gt;a.swedberg { color : #asd123 }&lt;/style&gt;')
    .appendTo('head');
</pre>
          </div>
          <div title="Utilizar $.data en Lugar de $.fn.data" class="section">
                  <h2>
                    Utilizar <code>$.data</code> en Lugar de <code>$.fn.data</code>
                  </h2>
            <p>
              Utilizar <code>$.data</code> en un elemento del DOM en lugar de <code>$.fn.data</code> en una selecci&oacute;n puede ser hasta 10 veces m&aacute;s r&aacute;pido. Antes de realizarlo, este seguro de comprender la diferencia entre un elemento DOM y una selecci&oacute;n jQuery.
            </p>
            <pre class="brush: js">
// regular
$(elem).data(key,value);

// 10 veces m&aacute;s r&aacute;pido
$.data(elem,key,value);
</pre>
          </div>
          <div title="No Actuar en Elementos no Existentes" class="section">
                  <h2>
                    No Actuar en Elementos no Existentes
                  </h2>
            <p>
              jQuery no le dir&aacute; si esta tratando de ejecutar c&oacute;digo en una selecci&oacute;n vac&iacute;a — esta se ejecutar&aacute; como si nada estuviera mal. Depender&aacute; de usted comprobar si la selecci&oacute;n contiene elementos.
            </p>
            <pre class="brush: js">
// MAL: el codigo a continuaci&oacute;n ejecuta tres funciones
// sin comprobar si existen elementos
// en la selecci&oacute;n
$('#nosuchthing').slideUp();

// Mejor
var $mySelection = $('#nosuchthing');
if ($mySelection.length) { $mySelection.slideUp(); }

// MUCHO MEJOR: a&ntilde;adir una extensi&oacute;n doOnce
jQuery.fn.doOnce = function(func){
    this.length &amp;&amp; func.apply(this);
    return this;

}


$('li.cartitems').doOnce(function(){

    // realizar algo

});
</pre>
            <p>
              Este consejo es especialmente aplicable para widgets de jQuery UI, los cuales poseen mucha carga incluso cuando la selecci&oacute;n no contiene elementos.
            </p>
          </div>
          <div title="Definici&oacute;n de Variables" class="section">
                  <h2>
                    Definici&oacute;n de Variables
                  </h2>
            <p>
              Las variables pueden ser definidas en una sola declaraci&oacute;n en lugar de varias.
            </p>
            <pre class="brush: js">
// antiguo
var test = 1;
var test2 = function() { ... };
var test3 = test2(test);

// mejor forma
var test = 1,
    test2 = function() { ... },
    test3 = test2(test);
</pre>
            <p>
              En funciones autoejecutables, las definiciones de variables pueden pasarse todas juntas.
            </p>
            <pre class="brush: js">
(function(foo, bar) { ... })(1, 2);
</pre>
          </div>
          <div title="Condicionales" class="section">
                  <h2>
                    Condicionales
                  </h2>
            <pre class="brush: js">
// antiguo
if (type == 'foo' || type == 'bar') { ... }

// mejor
if (/^(foo|bar)$/.test(type)) { ... }

// b&uacute;squeda en objeto literal
if (({ foo : 1, bar : 1 })[type]) { ... }
</pre>
          </div>
          <div title="No Tratar a jQuery como si fuera una Caja Negra" class="section">
                  <h2>
                    No Tratar a jQuery como si fuera una Caja Negra
                  </h2>
            <p>
              Utilice el c&oacute;digo fuente de la biblioteca como si fuera su documentaci&oacute;n — guarde el enlace <a href="http://bit.ly/jqsource">http://bit.ly/jqsource</a> como marcador para tener de referencia.
            </p>
          </div>
        </div>        <div id="capitulo-10" title="Organizaci&oacute;n del C&oacute;digo" class="chapter">
			<h2 class="title">Organizaci&oacute;n del C&oacute;digo</h2>
          
          <div title="Introducci&oacute;n" class="section">
            <h2>
              Introducci&oacute;n
            </h2>
            <p>
              Cuando se emprende la tarea de realizar aplicaciones complejas del lado del cliente, es necesario considerar la forma en que se organizar&aacute; el c&oacute;digo. Este capitulo esta dedicado a analizar algunos patrones de organizaci&oacute;n de c&oacute;digo para utilizar en una aplicaci&oacute;n realizada con jQuery y explorar el sistema de gesti&oacute;n de dependencias de RequireJS.
            </p>
          </div>
            
          <div title="Conceptos Clave" class="section">
                <h3>
                  Conceptos Clave
                </h3>
              <p>
                Antes de comenzar con los patrones de organizaci&oacute;n de c&oacute;digo, es importante entender algunos conceptos clave.
              </p>
              <ul>
                <li>El c&oacute;digo debe estar divido en unidades funcionales — m&oacute;dulos, servicios, etc. Y se debe evitar la tentaci&oacute;n de tener todo en un &uacute;nico bloque <code>$(document).ready()</code>. Este concepto se conoce como encapsulaci&oacute;n.
                </li>
                <li>
                  <p>
                    No repetir c&oacute;digo. Identificar piezas similares y utilizar t&eacute;cnicas de heredaci&oacute;n.
                  </p>
                </li>
                <li>
                  <p>
                    A pesar de la naturaleza de jQuery, no todas las aplicaciones JavaScript son sobre el DOM y no todas las piezas de funcionalidad tienen la necesidad de tener una representaci&oacute;n en el DOM.
                  </p>
                </li>
                <li>
                  <p>
                    Las unidades de funcionalidad deben tener una articulaci&oacute;n flexible (en ingl&eacute;s <a href="http://en.wikipedia.org/wiki/Loose_coupling">loosely coupled</a>) — una unidad de funcionalidad debe ser capaz de existir por si mismo y la comunicaci&oacute;n con otras unidades debe ser a trav&eacute;s de un sistema de mensajes como eventos personalizados o pub/sub. Y siempre que sea posible, mantener alejada la comunicaci&oacute;n directa entre unidades funcionales.
                  </p>
                </li>
              </ul>
              <p>
                El concepto de articulaci&oacute;n flexible puede ser especialmente problem&aacute;tico para desarrolladores que hacen su primera incursi&oacute;n en aplicaciones complejas, por lo que si esta empezando, este consciente de este concepto.
              </p>
          </div>
          
          <div title="Encapsulaci&oacute;n" class="section">
            <h2>
              Encapsulaci&oacute;n
            </h2>
            <p>
              El primer paso para la organizaci&oacute;n del c&oacute;digo es separar la aplicaci&oacute;n en distintas piezas; aunque a veces, este esfuerzo es suficiente.
            </p>
          </div>
           
          <div title="El Objeto Literal" class="section">
                <h3>
                  El Objeto Literal
                </h3>
              <p>
                Un objeto literal es tal vez la manera m&aacute;s simple de encapsular c&oacute;digo relacionado. Este no ofrece ninguna privacidad para propiedades o m&eacute;todos, pero es &uacute;til para eliminar funciones an&oacute;nimas, centralizar opciones de configuraci&oacute;n, y facilitar el camino para la reutilizaci&oacute;n y refactorizaci&oacute;n.
              </p>
              <div class="example">
                <p class="title">
                  <b>Un objeto literal</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var myFeature = {
    myProperty : 'hello',

    myMethod : function() {
        console.log(myFeature.myProperty);
    },

    init : function(settings) {
        myFeature.settings = settings;
    },

    readSettings : function() {
        console.log(myFeature.settings);
    }
};

myFeature.myProperty; // 'hello'
myFeature.myMethod(); // registra 'hello'
myFeature.init({ foo : 'bar' });
myFeature.readSettings(); // registra { foo : 'bar' }
</pre>
                </div>
              </div>
              <p>
                El objeto posee una propiedad y varios m&eacute;todos, los cuales son p&uacute;blicos, por lo que cualquier parte de la aplicaci&oacute;n puede verlos.
              </p>
              <p>
                ¿C&oacute;mo es posible aplicar este patr&oacute;n en c&oacute;digo jQuery? Por ejemplo, en el siguiente c&oacute;digo escrito en el estilo tradicional de jQuery:
              </p>
              <pre class="brush: js">
// haciendo click en un item de la lista se carga cierto contenid
// utilizando el ID de dicho item y a su vez oculta
// los otros items hermanos
$(document).ready(function() {
  $('#myFeature li')
    .append('&lt;div/&gt;')
    .click(function() {
      var $this = $(this);
      var $div = $this.find('div');
      $div.load('foo.php?item=' +
        $this.attr('id'),
        function() {
          $div.show();
          $this.siblings()
            .find('div').hide();
        }
      );
    });
});
</pre>
              <p>
                Si el ejemplo mostrado representa el 100% de la aplicaci&oacute;n, es conveniente dejarlo como esta. En cambio, si la pieza es solo una parte de una aplicaci&oacute;n m&aacute;s grande, estar&iacute;a bien separar dicha funcionalidad de otras no relacionadas. Por ejemplo, es conveniente mover la URL a la cual se hace la petici&oacute;n fuera del c&oacute;digo y pasarla al &aacute;rea de configuraci&oacute;n. Tambi&eacute;n romper la cadena de m&eacute;todos para hacer luego m&aacute;s f&aacute;cil la modificaci&oacute;n.
              </p>
              <div class="example">
                <p class="title">
                  <b>Utilizar un objeto literal para una funcionalidad jQuery</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var myFeature = {
    init : function(settings) {
        myFeature.config = {
            $items : $('#myFeature li'),
            $container : $('&lt;div class="container"&gt;&lt;/div&gt;'),
            urlBase : '/foo.php?item='
        };

        // permite sobreescribir la configuraci&oacute;n predeterminada
        $.extend(myFeature.config, settings);

        myFeature.setup();
    },

    setup : function() {
        myFeature.config.$items
            .each(myFeature.createContainer)
            .click(myFeature.showItem);
    },

    createContainer : function() {
        var $i = $(this),
            $c = myFeature.config.$container.clone()
                     .appendTo($i);

        $i.data('container', $c);
    },

    buildUrl : function() {
        return myFeature.config.urlBase +
               myFeature.$currentItem.attr('id');
    },

    showItem : function() {
        var myFeature.$currentItem = $(this);
        myFeature.getContent(myFeature.showContent);
    },

    getContent : function(callback) {
        var url = myFeature.buildUrl();
        myFeature.$currentItem
            .data('container').load(url, callback);
    },

    showContent : function() {
        myFeature.$currentItem
            .data('container').show();
        myFeature.hideContent();
    },

    hideContent : function() {
        myFeature.$currentItem.siblings()
            .each(function() {
                $(this).data('container').hide();
            });
    }
};

$(document).ready(myFeature.init);
</pre>
                </div>
              </div>
              <p>
                La primera caracter&iacute;stica a notar es que el c&oacute;digo es m&aacute;s largo que el original — como se dijo anteriormente, si este fuera el alcance de la aplicaci&oacute;n, utilizar un objeto literal seria probablemente una exageraci&oacute;n.
              </p>
              <p>
              	Las ventajas obtenidas son:
              </p>
              <ul>
                <li>
                  <p>
                    Separaci&oacute;n de cada funcionalidad en peque&ntilde;os m&eacute;todos. En un futuro, si se quiere cambiar la forma en que el contenido se muestra, ser&aacute; claro en donde habr&aacute; que hacerlo. En el c&oacute;digo original, este paso es mucho m&aacute;s dif&iacute;cil de localizar.
                  </p>
                </li>
                <li>
                  <p>
                    Se eliminaron los usos de funciones an&oacute;nimas.
                  </p>
                </li>
                <li>
                  <p>
                    Las opciones de configuraci&oacute;n se movieron a una ubicaci&oacute;n central.
                  </p>
                </li>
                <li>
                  <p>
                    Se eliminaron las limitaciones que poseen las cadenas de m&eacute;todos, haciendo que el c&oacute;digo sea m&aacute;s f&aacute;cil para refactorizar, mezclar y reorganizar.
                  </p>
                </li>
              </ul>
              <p>
                Por sus caracter&iacute;sticas, la utilizaci&oacute;n de objetos literales permiten una clara mejora para tramos largos de c&oacute;digo insertados en un bloque <code>$(document).ready()</code>. Sin embargo, no son m&aacute;s avanzados que tener varias declaraciones de funciones dentro de un bloque <code>$(document).ready()</code>.
              </p>
            </div>
            <div title="El Patr&oacute;n Modular" class="section">
                <h3>
                  El Patr&oacute;n Modular
                </h3>
              <p>
                El patr&oacute;n modular supera algunas limitaciones del objeto literal, ofreciendo privacidad para variables y funciones, exponiendo a su vez (si se lo desea) una API p&uacute;blica.
              </p>
              <div class="example">
                <p class="title">
                  <b>El patr&oacute;n modular</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
var feature =(function() {

    // variables y funciones privadas
    var privateThing = 'secret',
        publicThing = 'not secret',

        changePrivateThing = function() {
            privateThing = 'super secret';
        },

        sayPrivateThing = function() {
            console.log(privateThing);
            changePrivateThing();
        };

    // API publica
    return {
        publicThing : publicThing,
        sayPrivateThing : sayPrivateThing
    }

})();

feature.publicThing; // registra 'not secret'

feature.sayPrivateThing();
// registra 'secret' y cambia el valor
// de privateThing
</pre>
                </div>
              </div>
              <p>
                En el ejemplo, se autoejecuta una funci&oacute;n an&oacute;nima la cual devuelve un objeto. Dentro de la funci&oacute;n, se definen algunas variables. Debido a que ellas son definidas dentro de la funci&oacute;n, desde afuera no se tiene acceso a menos que se pongan dentro del objeto que se devuelve. Esto implica que ning&uacute;n c&oacute;digo fuera de la funci&oacute;n tiene acceso a la variable <code>privateThing</code> o a la funci&oacute;n <code>sayPrivateThing</code>. Sin embargo, <code>sayPrivateThing</code> posee acceso a <code>privateThing</code> y <code>changePrivateThing</code> debido a estar definidos en el mismo alcance.
              </p>
              <p>
                El patr&oacute;n es poderoso debido a que permite tener variables y funciones privadas, exponiendo una API limitada consistente en devolver propiedades y m&eacute;todos de un objeto.
              </p>
              <p>
                A continuaci&oacute;n se muestra una revisi&oacute;n del ejemplo visto anteriormente, con las mismas caracter&iacute;sticas, pero exponiendo un &uacute;nico m&eacute;todo p&uacute;blico del modulo, <code>showItemByIndex()</code>.
              </p>
              <div class="example">
                <p class="title">
                  <b>Utilizar el patr&oacute;n modular para una funcionalidad jQuery</b>
                </p>
                <div class="example-contents">
                  <pre class="brush: js">
$(document).ready(function() {
    var feature = (function() {

        var $items = $('#myFeature li'),
            $container = $('&lt;div class="container"&gt;&lt;/div&gt;'),
            $currentItem,

            urlBase = '/foo.php?item=',

            createContainer = function() {
                var $i = $(this),
                    $c = $container.clone().appendTo($i);

                $i.data('container', $c);
            },

            buildUrl = function() {
                return urlBase + $currentItem.attr('id');
            },

            showItem = function() {
                var $currentItem = $(this);
                getContent(showContent);
            },

            showItemByIndex = function(idx) {
                $.proxy(showItem, $items.get(idx));
            },

            getContent = function(callback) {
                $currentItem.data('container').load(buildUrl(), callback);
            },

            showContent = function() {
                $currentItem.data('container').show();
                hideContent();
            },

            hideContent = function() {
                $currentItem.siblings()
                    .each(function() {
                        $(this).data('container').hide();
                });
            };

        $items
            .each(createContainer)
            .click(showItem);

        return { showItemByIndex : showItemByIndex };
    })();

    feature.showItemByIndex(0);
});
</pre>
                </div>
              </div>
          </div>
          
          <div title="Gesti&oacute;n de Dependencias" class="section">
          <h2>
              Gesti&oacute;n de Dependencias
          </h2>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Esta secci&oacute;n esta basada en la excelente documentaci&oacute;n de RequireJS <a href="http://requirejs.org/docs/jquery.html">http://requirejs.org/docs/jquery.html</a> y es utilizada con el permiso de James Burke, autor de RequireJS.
          </p>
          </div>
          <p>
            Cuando un proyecto alcanza cierto tama&ntilde;o, comienza a ser dif&iacute;cil el manejo de los m&oacute;dulos de una aplicaci&oacute;n, ya que es necesario saber ordenarlos de forma correcta, y comenzar a combinarlos en un &uacute;nico archivo para lograr la menor cantidad de peticiones. Tambi&eacute;n es posible que se quiera cargar c&oacute;digo "al vuelo" luego de la carga de la p&aacute;gina.
          </p>
          <p>
            RequireJS es una herramienta de gesti&oacute;n de dependencias creada por James Burke, la cual ayuda a manejar los m&oacute;dulos, cargarlos en un orden correcto y combinarlos de forma f&aacute;cil sin tener que realizar ning&uacute;n cambio. A su vez, otorga una manera f&aacute;cil de cargar c&oacute;digo una vez cargada la p&aacute;gina, permitiendo minimizar el tiempo de descarga.
          </p>
          <p>
            RequireJS posee un sistema modular, que sin embargo, no es necesario seguirlo para obtener sus beneficios. El formato modular de RequireJS permite la escritura de c&oacute;digo encapsulado, incorporaci&oacute;n de internacionalizaci&oacute;n (i18n) a los paquetes (para permitir utilizarlos en diferentes lenguajes) e incluso la utilizaci&oacute;n de servicios JSONP como dependencias.
          </p>
          </div>
          
          <div title="Obtener RequireJS" class="section">
			  <h3>
                Obtener RequireJS
              </h3>
            <p>
              La manera m&aacute;s f&aacute;cil de utilizar RequireJS con jQuery es descargando <a href="http://requirejs.org/docs/download.html">el paquete de jQuery con RequireJS</a> ya incorporado en &eacute;l. Este paquete excluye porciones de c&oacute;digo que duplican funciones de jQuery. Tambi&eacute;n es &uacute;til descargar <a href="http://requirejs.org/docs/release/0.11.0/jquery-require-sample.zip">un ejemplo de proyecto jQuery que utiliza RequireJS</a>.
            </p>
          </div>
          
         <div title="Utilizar RequireJS con jQuery" class="section">
              <h3>
                Utilizar RequireJS con jQuery
              </h3>
            <p>
              Utilizar RequireJS es simple, tan solo es necesario incorporar en la p&aacute;gina la versi&oacute;n de jQuery que posee RequireJS incorporado y a continuaci&oacute;n solicitar los archivos de la aplicaci&oacute;n. El siguiente ejemplo asume que tanto jQuery como los otros archivos est&aacute;n dentro de la carpeta <code class="filename">scripts/</code>.
            </p>
            <div class="example">
              <p class="title">
                <b>Utilizar RequireJS: Un ejemplo simple</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;jQuery+RequireJS Sample Page&lt;/title&gt;
        &lt;script src="scripts/require-jquery.js"&gt;&lt;/script&gt;
        &lt;script&gt;require(["app"]);&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;jQuery+RequireJS Sample Page&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
              </div>
            </div>
            <p>
              La llamada a <code>require(["app"])</code> le dice a RequireJS que cargue el archivo <code class="filename">scripts/app.js</code>. RequireJS cargar&aacute; cualquier dependencia pasada a <code>require()</code> sin la extensi&oacute;n <code class="filename">.js</code> desde el mismo directorio que en que se encuentra el archivo <code class="filename">require-jquery.js</code>, aunque tambi&eacute;n es posible especificar la ruta de la siguiente forma:
            </p>
            <pre class="brush: js">
&lt;script&gt;require(["scripts/app.js"]);&lt;/script&gt;
</pre>
            <p>
              El archivo <code class="filename">app.js</code> es otra llamada a <code class="filename">require.js</code> para cargar todos los archivos necesarios para la aplicaci&oacute;n. En el siguiente ejemplo, <code class="filename">app.js</code> solicita dos extensiones <code class="filename">jquery.alpha.js</code> y <code class="filename">jquery.beta.js</code> (no son extensiones reales, solo ejemplos). Estas extensiones est&aacute;n en la misma carpeta que <code class="filename">require-jquery.js</code>:
            </p>
            <div class="example">
              <p class="title">
                <b>Un simple archivo JavaScript con dependencias</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
require(["jquery.alpha", "jquery.beta"], function() {
    //las extensiones jquery.alpha.js y jquery.beta.js han sido cargadas.
    $(function() {
        $('body').alpha().beta();
    });
});
</pre>
              </div>
            </div>
          </div>
          
          <div title="Crear M&oacute;dulos Reusables con RequireJS" class="section">
              <h3>
                Crear M&oacute;dulos Reusables con RequireJS
              </h3>
            <p>
              RequireJS hace que sea f&aacute;cil definir m&oacute;dulos reusables a trav&eacute;s de <code>require.def()</code>. Un modulo RequireJS puede tener dependencias que pueden ser utilizadas para definir un m&oacute;dulo, adem&aacute;s de poder devolver un valor — un objeto, una funci&oacute;n, u otra cosa — que puede ser incluso utilizado otros m&oacute;dulos.
            </p>
            <p>
              Si el m&oacute;dulo no posee ninguna dependencia, tan solo se debe especificar el nombre como primer argumento de <code>require.def()</code>. El segundo argumento es un objeto literal que define las propiedades del m&oacute;dulo. Por ejemplo:
            </p>
            <div class="example">
              <p class="title">
                <b>Definici&oacute;n de un m&oacute;dulo RequireJS que no posee dependencias</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
require.def("my/simpleshirt",
    {
        color: "black",
        size: "unisize"
    }
);
</pre>
              </div>
            </div>
                <p>
                  El ejemplo debe ser guardado en el archivo my/simpleshirt.js.
                </p>
                <p>
                  Si el modulo posee dependencias, es posible especificarlas en el segundo argumento de <code>require.def()</code> a trav&eacute;s de un arreglo) y luego pasar una funci&oacute;n como tercer argumento. Esta funci&oacute;n ser&aacute; llamada para definir el m&oacute;dulo una vez cargadas todos las dependencias. Dicha funci&oacute;n recibe los valores devueltos por las dependencias como un argumento (en el mismo orden en que son requeridas en el arreglo) y luego la misma debe devolver un objeto que defina el m&oacute;dulo.
                </p>
                <div class="example">
                  <p class="title">
                    <b>Definici&oacute;n de un m&oacute;dulo RequireJS con dependencias</b>
                  </p>
                  <div class="example-contents">
                    <pre class="brush: js">
require.def("my/shirt",
    ["my/cart", "my/inventory"],
    function(cart, inventory) {
        //devuelve un objeto que define a "my/shirt"
        return {
            color: "blue",
            size: "large"
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
);
</pre>
                  </div>
                </div>
                <p>
                  En este ejemplo, el modulo my/shirt es creado. Este depende de my/cart y my/inventory. En el disco, los archivos est&aacute;n estructurados de la siguiente forma:
                </p>
                <pre class="brush: js">
my/cart.js
my/inventory.js
my/shirt.js
</pre>
                <p>
                  La funci&oacute;n que define <code>my/shirt</code> no es llamada hasta que <code>my/cart</code> y <code>my/inventory</code> hayan sido cargadas, y dicha funci&oacute;n recibe como argumentos a los m&oacute;dulos como <code>cart</code> y <code>inventory</code>. El orden de los argumentos de la funci&oacute;n debe coincidir con el orden en que las dependencias se requieren en el arreglo. El objeto devuelto define el m&oacute;dulo <code>my/shirt</code>. Definiendo los m&oacute;dulos de esta forma, my/shirt no existe como un objeto global, ya que m&uacute;ltiples m&oacute;dulos pueden existir en la p&aacute;gina al mismo tiempo.
                </p>
                <p>
                  Los m&oacute;dulos no tienen que devolver un objeto; cualquier tipo de valor es permitido.
                </p>
                <div class="example">
                  <p class="title">
                    <b>Definici&oacute;n de un m&oacute;dulo RequireJS que devuelve una funci&oacute;n</b>
                  </p>
                  <div class="example-contents">
                    <pre class="brush: js">
require.def("my/title",
    ["my/dependency1", "my/dependency2"],
    function(dep1, dep2) {
        //devuelve una funci&oacute;n para definir "my/title". Este devuelve o establece
        //el titulo de la ventana
        return function(title) {
            return title ? (window.title = title) : window.title;
        }
    }
);
</pre>
                  </div>
                </div>
                <p>
                  Solo un m&oacute;dulo debe ser requerido por archivo JavaScript.
                </p>
          </div>
          <div title="Optimizar el C&oacute;digo con las Herramientas de RequireJS" class="section">
              <h3>
                Optimizar el C&oacute;digo con las Herramientas de RequireJS
              </h3>
            <p>
              Una vez incorporado RequireJS para el manejo de dependencias, la optimizaci&oacute;n del c&oacute;digo es muy f&aacute;cil. Descargue el paquete de RequireJS y col&oacute;quelo en cualquier lugar, preferentemente fuera del &aacute;rea de desarrollo web. Para los prop&oacute;sitos de este ejemplo, el paquete de RequireJS esta ubicado en una carpeta paralela al directorio <code class="filename">webapp</code> (la cual contiene la p&aacute;gina HTML y todos los archivos JavaScript de la aplicaci&oacute;n). La estructura de directorios es:
            </p>
            <pre class="brush: js">
requirejs/ (utilizado para ejecutar las herramientas)
webapp/app.html
webapp/scripts/app.js
webapp/scripts/require-jquery.js
webapp/scripts/jquery.alpha.js
webapp/scripts/jquery.beta.js
</pre>
            <p>
              Then, in the scripts directory that has <code class="filename">require-jquery.js</code> and app.js, create a file called app.build.js with the following contents:
              Luego, en la carpeta en donde se encuentran <code class="filename">require-jquery.js</code> y <code class="filename">app.js</code>, crear un archivo llamado <code class="filename">app.build.js</code> con el siguiente contenido:
            </p>
            <div class="example">
              <p class="title">
                <b>Archivo de configuraci&oacute;n para las herramientas de optimizaci&oacute;n de RequireJS</b>
              </p>
              <div class="example-contents">
                <pre class="brush: js">
{
    appDir: "../",
    baseUrl: "scripts/",
    dir: "../../webapp-build",
    //Comentar la siguiente l&iacute;nea si se desea
    //minificar el c&oacute;digo por el compilador
    //en su modo "simple"
    optimize: "none",

    modules: [
        {
            name: "app"
        }
    ]
}
</pre>
              </div>
            </div>
            <p>
              Para utilizar la herramienta, es necesario tener instalado Java 6. <a href="http://code.google.com/closure/compiler/">Closure Compiler</a> es utilizado para la minificaci&oacute;n del c&oacute;digo (en caso que <code>optimize: "none"</code> est&eacute; comentado).
            </p>
            <p>
              Para comenzar a procesar los archivos, abrir una ventana de comandos, dirigirse al directorio webapp/scripts y ejecutar:
            </p>
            <pre class="brush: js">
# para sistemas que no son windows
../../requirejs/build/build.sh app.build.js

# para sistemas windows
..\..\requirejs\build\build.bat app.build.js
</pre>
            <p>
              Una vez ejecutado, el archivo <code class="filename">app.js</code> de la carpeta webapp-build contendr&aacute; todo el c&oacute;digo de <code class="filename">app.js</code> m&aacute;s el de <code class="filename">jquery.alpha.js</code> y <code class="filename">jquery.beta.js</code>. Si se abre el archivo <code class="filename">app.html</code> (tambi&eacute;n en la carpeta <code class="filename">webapp-build</code>) podr&aacute; notar que ninguna petici&oacute;n se realiza para cargar <code class="filename">jquery.alpha.js</code> y <code class="filename">jquery.beta.js</code>.
            </p>
          </div>
          <div title="Ejercicios" class="section">
            <h2>
              Ejercicios
            </h2>
            <div title="Crear un M&oacute;dulo Portlet" class="section">
                <h3>
                  Crear un M&oacute;dulo Portlet
                </h3>
              <p>
                Abra el archivo <code class="filename">/exercises/portlets.html</code> en el navegador. Realice el ejercicio utilizando el archivo <code class="filename">/exercises/js/portlets.js</code>. El ejercicio consiste en crear una funci&oacute;n creadora de portlet que utilice el patr&oacute;n modular, de tal manera que el siguiente c&oacute;digo funcione:
              </p>
              <pre class="brush: js">
var myPortlet = Portlet({
    title : 'Curry',
    source : 'data/html/curry.html',
    initialState : 'open' // or 'closed'
});

myPortlet.$element.appendTo('body');
</pre>
              <p>
                Cada portlet deber&aacute; ser un <code>div</code> con un t&iacute;tulo, un &aacute;rea de contenido, un bot&oacute;n para abrir/cerrar el portlet, un bot&oacute;n para removerlo y otro para actualizarlo. El portlet devuelto por la funci&oacute;n deber&aacute; tener la siguiente API p&uacute;blica:
              </p>
              <pre class="brush: js">
myPortlet.open(); // fuerza a abrir
myPortlet.close(); // fuerza a cerrar
myPortlet.toggle(); // alterna entre los estados abierto y cerrado
myPortlet.refresh(); // actualiza el contenido
myPortlet.destroy(); // remueve el portlet de la p&aacute;gina
myPortlet.setSource('data/html/onions.html'); // cambia el c&oacute;digo
</pre>
            </div>
          </div>

        </div>        <div id="capitulo-11" title="Eventos Personalizados" class="chapter">
			<h2 class="title">Eventos Personalizados</h2>
          <h2>
            Introducci&oacute;n a los Eventos Personalizados
          </h2>
          <p>
            Todos estamos familiarizados con los eventos b&aacute;sicos — <code>click</code>, <code>mouseover</code>, <code>focus</code>, <code>blur</code>, <code>submit</code>, etc. — que surgen a partir de la interacci&oacute;n del usuario con el navegador.
          </p>
          <p>
            Los eventos personalizados permiten conocer el mundo de la programaci&oacute;n orientada a eventos (en ingl&eacute;s <em>event-driven programming</em>). En este cap&iacute;tulo, se utilizar&aacute; el sistema de eventos personalizados de jQuery para crear una simple aplicaci&oacute;n de b&uacute;squeda en <em>Twitter</em>.
          </p>
          <p>
          	En un primer momento puede ser dif&iacute;cil entender el requisito de utilizar eventos personalizados, ya que los eventos convencionales permiten satisfacer todas las necesidades. Sin embargo, los eventos personalizados ofrecen una nueva forma de pensar la programaci&oacute;n en JavaScript. En lugar de enfocarse en el elemento que ejecuta una acci&oacute;n, los eventos personalizados ponen la atenci&oacute;n en el elemento en donde la acci&oacute;n va a ocurrir. Este concepto brinda varios beneficios:
          </p>
          <ul>
            <li>
              <p>
                Los comportamientos del elemento objetivo pueden ser ejecutados por diferentes elementos utilizando el mismo c&oacute;digo.
              </p>
            </li>
            <li>
              <p>
                Los comportamientos pueden ser ejecutados en m&uacute;ltiples, similares elementos objetivos a la vez.
              </p>
            </li>
            <li>
              <p>
                Los comportamientos son asociados de forma m&aacute;s clara con el elemento objetivo, haciendo que el c&oacute;digo sea m&aacute;s f&aacute;cil de leer y mantener.
              </p>
            </li>
          </ul>
          <p>
            Un ejemplo es la mejor forma de explicar el asunto. Suponga que posee una l&aacute;mpara incandescente en una habitaci&oacute;n de una casa. La l&aacute;mpara actualmente esta encendida. La misma es controlada por dos interruptores de tres posiciones y un <em>clapper</em> (interruptor activado por aplausos):
          </p>
          <pre class="brush: js">
&lt;div class="room" id="kitchen"&gt;
    &lt;div class="lightbulb on"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="clapper"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
          <p>
            Ejecutando el <em>clapper</em> o alguno de los interruptores, el estado de la lampara cambia. A los interruptores o al <em>clapper</em> no le interesan si la l&aacute;mpara esta prendida o apagada, tan solo quieren cambiar su estado
          </p>
          <p>
            Sin la utilizaci&oacute;n de eventos personalizados, es posible escribir la rutina de la siguiente manera:
          </p>
          <pre class="brush: js">
$('.switch, .clapper').click(function() {
    var $light = $(this).parent().find('.lightbulb');
    if ($light.hasClass('on')) {
        $light.removeClass('on').addClass('off');
    } else {
        $light.removeClass('off').addClass('on');
    }
});
</pre>
          <p>
            Por otro lado, utilizando eventos personalizados, el c&oacute;digo queda as&iacute;:
          </p>
          <pre class="brush: js">
$('.lightbulb').bind('changeState', function(e) {
    var $light = $(this);
    if ($light.hasClass('on')) {
        $light.removeClass('on').addClass('off');
    } else {
        $light.removeClass('off').addClass('on');
    }
});

$('.switch, .clapper').click(function() {
    $(this).parent().find('.lightbulb').trigger('changeState');
});
</pre>
          <p>
            Algo importante ha sucedido: el comportamiento de la l&aacute;mpara se ha movido, antes estaba en los interruptores y en el <em>clapper</em>, ahora se encuentra en la misma l&aacute;mpara.
          </p>
          <p>
            Tambi&eacute;n es posible hacer el ejemplo un poco m&aacute;s interesante. Suponga que se ha a&ntilde;adido otra habitaci&oacute;n a la casa, junto con un interruptor general, como se muestra a continuaci&oacute;n:
          </p>
          <pre class="brush: js">
&lt;div class="room" id="kitchen"&gt;
    &lt;div class="lightbulb on"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="clapper"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="room" id="bedroom"&gt;
    &lt;div class="lightbulb on"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="switch"&gt;&lt;/div&gt;
    &lt;div class="clapper"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="master_switch"&gt;&lt;/div&gt;
</pre>
          <p>
            Si existe alguna l&aacute;mpara prendida en la casa, es posible apagarlas a trav&eacute;s del interruptor general, de igual forma si existen luces apagadas, es posible prenderlas con dicho interruptor. Para realizar esta tarea, se agregan dos eventos personalizados m&aacute;s a la l&aacute;mpara: <code>turnOn</code> y <code>turnOff</code>. A trav&eacute;s de una l&oacute;gica en el evento <code>changeState</code> se decide qu&eacute; evento personalizado utilizar:
          </p>
          <pre class="brush: js">
$('.lightbulb')
    .bind('changeState', function(e) {
        var $light = $(this);
        if ($light.hasClass('on')) {
            $light.trigger('turnOff');
        } else {
            $light.trigger('turnOn');
        }
    })
    .bind('turnOn', function(e) {
        $(this).removeClass('off').addClass('on');
    })
    .bind('turnOff', function(e) {
        $(this).removeClass('off').addClass('on');
    });

$('.switch, .clapper').click(function() {
    $(this).parent().find('.lightbulb').trigger('changeState');
});

$('#master_switch').click(function() {
    if ($('.lightbulb.on').length) {
        $('.lightbulb').trigger('turnOff');
    } else {
        $('.lightbulb').trigger('turnOn');
    }
});
</pre>
          <p>
            Note como el comportamiento del interruptor general se ha vinculado al interruptor general mientras que el comportamiento de las l&aacute;mparas pertenece a las l&aacute;mparas.
          </p>
          <div class="note">
          <h3>
            Nota
          </h3>
          <p>
            Si esta acostumbrado a la programaci&oacute;n orientada a objetos, puede resultar &uacute;til pensar de los eventos personalizados como m&eacute;todos de objetos. En t&eacute;rminos generales, el objeto al que pertenece el m&eacute;todo se crea a partir del selector jQuery. Vincular el evento personalizado <code>changeState</code> a todos los elementos <code>$(‘.light’)</code> es similar a tener una clase llamada <code>Light</code> con un m&eacute;todo <code>changeState</code>, y luego instanciar nuevos objetos <code>Light</code> por cada elemento.
          </p>
          </div>
          <div title="Recapitulaci&oacute;n: $.fn.bind y $.fn.trigger" class="sidebar">
            <p class="title">
              <b>Recapitulaci&oacute;n: $.fn.bind y $.fn.trigger</b>
            </p>
            <p>
              En el mundo de los eventos personalizados, existen dos m&eacute;todos importantes de jQuery: <code>$.fn.bind</code> y <code>$.fn.trigger</code>. En el cap&iacute;tulo dedicado a eventos se explic&oacute; la utilizaci&oacute;n de estos dos m&eacute;todos para trabajar con eventos del usuario; en este cap&iacute;tulo es importante recordar 2 puntos:
            </p>
            <ul>
              <li>El m&eacute;todo <code>$.fn.bind</code> toma como argumentos un tipo de evento y una funci&oacute;n controladora de evento. Opcionalmente, puede recibir informaci&oacute;n asociada al evento como segundo argumento, desplazando como tercer argumento a la funci&oacute;n controladora de evento. Cualquier informaci&oacute;n pasada estar&aacute; disponible a la funci&oacute;n controladora a trav&eacute;s de la propiedad <code>data</code> del objeto del evento. A su vez, la funci&oacute;n controladora recibe el objeto del evento como primer argumento.
              </li>
              <li>El m&eacute;todo <code>$.fn.trigger</code> toma como argumentos el tipo de evento y opcionalmente, puede tomar un arreglo con valores. Estos valores ser&aacute;n pasados a la funci&oacute;n controladora de eventos como argumentos luego del objeto del evento.
              </li>
            </ul>
            <p>
              A continuaci&oacute;n se muestra un ejemplo de utilizaci&oacute;n de <code>$.fn.bind</code> y <code>$.fn.trigger</code> en donde se utiliza informaci&oacute;n personalizada en ambos casos:
            </p>
            <pre class="brush: js">
$(document).bind('myCustomEvent', { foo : 'bar' }, function(e, arg1, arg2) {
    console.log(e.data.foo); // 'bar'
    console.log(arg1); // 'bim'
    console.log(arg2); // 'baz'
});

$(document).trigger('myCustomEvent', [ 'bim', 'baz' ]);
</pre>
          </div>
          <div title="Un Ejemplo de Aplicaci&oacute;n" class="section">
              <h3>
                Un Ejemplo de Aplicaci&oacute;n
              </h3>
            <p>
              Para demostrar el poder de los eventos personalizados, se desarrollar&aacute; una simple herramienta para buscar en <em>Twitter</em>. Dicha herramienta ofrecer&aacute; varias maneras para que el usuario realice una b&uacute;squeda: ingresando el t&eacute;rmino a buscar en una caja de texto &oacute; consultando los "temas de moda" de <em>Twitter</em>.
            </p>
            <p>
              Los resultados de cada t&eacute;rmino se mostrar&aacute;n en un contenedor de resultados; dichos resultados podr&aacute;n expandirse, colapsarse, refrescarse y removerse, ya sea de forma individual o conjunta.
            </p>
            <p>
              El resultado final de la aplicaci&oacute;n ser&aacute; el siguiente:
            </p>
            <div class="figure">
              <p class="title">
                <b>Figura&nbsp;11.1.&nbsp;La aplicaci&oacute;n finalizada</b>
              </p>
              <div class="figure-contents">
                <div class="screenshot">
                  <div class="mediaobject">
                    <img alt="La aplicaci&oacute;n finalizada" src="http://gyazo.com/70415e9fffab1c47953f5264ecf722fe.png">
                  </div>
                </div>
              </div>
            </div><br class="figure-break">
            <div title="Iniciaci&oacute;n" class="section">
                <h4>
                  Iniciaci&oacute;n
                </h4>
              <p>
                Se empieza con un HTML b&aacute;sico:
              </p>
              <pre class="brush: js">
&lt;h1&gt;Twitter Search&lt;/h1&gt;
&lt;input type="button" id="get_trends"
    value="Load Trending Terms" /&gt;

&lt;form&gt;
    &lt;input type="text" class="input_text"
        id="search_term" /&gt;
    &lt;input type="submit" class="input_submit"
        value="Add Search Term" /&gt;
&lt;/form&gt;

&lt;div id="twitter"&gt;
    &lt;div class="template results"&gt;
        &lt;h2&gt;Search Results for
        &lt;span class="search_term"&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
              <p>
                El HTML posee un contenedor (#twitter) para el widget, una plantilla para los resultados (oculto con CSS) y un simple formulario en donde el usuario puede escribir el t&eacute;rmino a buscar.
              </p>
              <p>
                Existen dos tipos de elementos en los cuales actuar: los contenedores de resultados y el contenedor <em>Twitter</em>.
              </p>
              <p>
                Los contenedores de resultados son el coraz&oacute;n de la aplicaci&oacute;n. Se crear&aacute; una extensi&oacute;n para preparar cada contenedor una vez que &eacute;ste se agrega al contenedor <em>Twitter</em>. Adem&aacute;s, entre otras cosas, la extensi&oacute;n vincular&aacute; los eventos personalizados por cada contenedor y a&ntilde;adir&aacute; en la parte superior derecha de cada contenedor botones que ejecutar&aacute;n acciones. Cada contenedor de resultados tendr&aacute; los siguientes eventos personalizados:
              </p>
              <div class="variablelist">
                <dl>
                  <dt>
                    <span class="term">refresh</span>
                  </dt>
                  <dd>
                    <p>
                      Se&ntilde;ala que la informaci&oacute;n del contenedor se esta actualizando y dispara la petici&oacute;n que busca los datos para el t&eacute;rmino de b&uacute;squeda.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">populate</span>
                  </dt>
                  <dd>
                    <p>
                      Recibe la informaci&oacute;n JSON y la utiliza para rellenar el contenedor.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">remove</span>
                  </dt>
                  <dd>
                    <p>
                      Remueve el contenedor de la p&aacute;gina luego de que el usuario confirme la acci&oacute;n. Dicha confirmaci&oacute;n puede omitirse si se pasa <code>true</code> como segundo argumento del controlador de evento. El evento adem&aacute;s remueve el t&eacute;rmino asociado con el contenedor de resultados del objeto global que contiene los t&eacute;rminos de b&uacute;squeda.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">collapse</span>
                  </dt>
                  <dd>
                    <p>
                      A&ntilde;ade una clase al contenedor, la cual ocultar&aacute; el resultado a trav&eacute;s de CSS. Adem&aacute;s cambiar&aacute; el bot&oacute;n de "Colapsar" a "Expandir".
                    </p>
                  </dd>
                  <dt>
                    <span class="term">expand</span>
                  </dt>
                  <dd>
                    <p>
                      Remueve la clase del contenedor que a&ntilde;ade el evento <em>collapse</em>. Adem&aacute;s cambiar&aacute; el bot&oacute;n de "Expandir" a "Colapsar".
                    </p>
                  </dd>
                </dl>
              </div>
              <p>
               Adem&aacute;s, la extensi&oacute;n es responsable de a&ntilde;adir los botones de acciones al contenedor, vinculando un evento <code>click</code> a cada bot&oacute;n y utilizando la clase de cada &iacute;tem para determinar qu&eacute; evento personalizado ser&aacute; ejecutado en cada contenedor de resultados.
              </p>
              <pre class="brush: js">
$.fn.twitterResult = function(settings) {
    return this.each(function() {
        var $results = $(this),
            $actions = $.fn.twitterResult.actions =
                $.fn.twitterResult.actions ||
                $.fn.twitterResult.createActions(),
            $a = $actions.clone().prependTo($results),
            term = settings.term;

        $results.find('span.search_term').text(term);

        $.each(
            ['refresh', 'populate', 'remove', 'collapse', 'expand'],
            function(i, ev) {
                $results.bind(
                    ev,
                    { term : term },
                    $.fn.twitterResult.events[ev]
                );
            }
        );

        // utiliza la clase de cada acci&oacute;n para determinar
        // que evento se ejecutar&aacute; en el panel de resultados
        $a.find('li').click(function() {
            // pasa el elemento &lt;li&gt; clickeado en la funci&oacute;n
            // para que se pueda manipular en caso de ser necesario
            $results.trigger($(this).attr('class'), [ $(this) ]);
        });
    });
};

$.fn.twitterResult.createActions = function() {
    return $('&lt;ul class="actions" /&gt;').append(
        '&lt;li class="refresh"&gt;Refresh&lt;/li&gt;' +
        '&lt;li class="remove"&gt;Remove&lt;/li&gt;' +
        '&lt;li class="collapse"&gt;Collapse&lt;/li&gt;'
    );
};

$.fn.twitterResult.events = {
    refresh : function(e) {
           // indica que los resultados se estan actualizando
        var $this = $(this).addClass('refreshing');

        $this.find('p.tweet').remove();
        $results.append('&lt;p class="loading"&gt;Loading ...&lt;/p&gt;');

        // obtiene la informaci&oacute;n de Twitter en formato jsonp
        $.getJSON(
            'http://search.twitter.com/search.json?q=' +
                escape(e.data.term) + '&amp;rpp=5&amp;callback=?',
            function(json) {
                $this.trigger('populate', [ json ]);
            }
        );
    },

    populate : function(e, json) {
        var results = json.results;
        var $this = $(this);

        $this.find('p.loading').remove();

        $.each(results, function(i,result) {
            var tweet = '&lt;p class="tweet"&gt;' +
                '&lt;a href="http://twitter.com/' +
                result.from_user +
                '"&gt;' +
                result.from_user +
                '&lt;/a&gt;: ' +
                result.text +
                ' &lt;span class="date"&gt;' +
                result.created_at +
                '&lt;/span&gt;' +
            '&lt;/p&gt;';
            $this.append(tweet);
        });

        // indica que los resultados
        // ya se han actualizado
        $this.removeClass('refreshing');
    },

    remove : function(e, force) {
        if (
            !force &amp;&amp;
            !confirm('Remove panel for term ' + e.data.term + '?')
        ) {
            return;
        }
        $(this).remove();

        // indica que ya no se tendr&aacute;
        // un panel para el t&eacute;rmino
        search_terms[e.data.term] = 0;
    },

    collapse : function(e) {
        $(this).find('li.collapse').removeClass('collapse')
            .addClass('expand').text('Expand');

        $(this).addClass('collapsed');
    },

    expand : function(e) {
        $(this).find('li.expand').removeClass('expand')
            .addClass('collapse').text('Collapse');

        $(this).removeClass('collapsed');
    }
};
</pre>
              <p>
                El contenedor <em>Twitter</em>, posee solo dos eventos personalizados:
              </p>
              <div class="variablelist">
                <dl>
                  <dt>
                    <span class="term">getResults</span>
                  </dt>
                  <dd>
                    <p>
                      Recibe un t&eacute;rmino de b&uacute;squeda y comprueba si ya no existe un contenedor de resultados para dicho t&eacute;rmino. En caso de no existir, a&ntilde;ade un contenedor utilizando la plantilla de resultados, lo configura utilizando la extensi&oacute;n <code>$.fn.twitterResult</code> (mostrada anteriormente) y luego ejecuta el evento <code>refresh</code> con el fin de cargar correctamente los resultados. Finalmente, guarda el t&eacute;rmino buscado para no tener volver a pedir los datos sobre la b&uacute;squeda.
                    </p>
                  </dd>
                  <dt>
                    <span class="term">getTrends</span>
                  </dt>
                  <dd>
                    <p>
                      Consulta a <em>Twitter</em> el listado de los 10 primeros "t&eacute;rminos de moda", interact&uacute;a con ellos y ejecuta el evento <code>getResults</code> por cada uno, de tal modo que a&ntilde;ade un contenedor de resultados por cada t&eacute;rmino.
                    </p>
                  </dd>
                </dl>
              </div>
              <p>
                Vinculaciones en el contenedor <em>Twitter</em>:
              </p>
              <pre class="brush: js">
$('#twitter')
    .bind('getResults', function(e, term) {
        // se comprueba que ya no exista una caja para el t&eacute;rmino
        if (!search_terms[term]) {
            var $this = $(this);
            var $template = $this.find('div.template');

            // realiza una copia de la plantilla
            // y la inserta como la primera caja de resultados
            $results = $template.clone().
                removeClass('template').
                insertBefore($this.find('div:first')).
                twitterResult({
                    'term' : term
                });

            // carga el contenido utilizando el evento personalizado "refresh"
            // vinculado al contenedor de resultados
            $results.trigger('refresh');
            search_terms[term] = 1;
        }
    })
    .bind('getTrends', function(e) {
        var $this = $(this);
        $.getJSON('http://search.twitter.com/trends.json?callback=?', function(json) {
                var trends = json.trends;
                $.each(trends, function(i, trend) {
                    $this.trigger('getResults', [ trend.name ]);
                });
            });
    });
</pre>
              <p>
                Hasta ahora, se ha escrito una gran cantidad de c&oacute;digo que no realiza nada, lo cual no esta mal. Se han especificado todos los comportamientos que se desean para los elementos n&uacute;cleos y se ha creado un s&oacute;lido marco para la creaci&oacute;n r&aacute;pida de la interfaz.
              </p>
              <p>
                A continuaci&oacute;n, se conecta la caja de b&uacute;squeda y el bot&oacute;n para cargar los "Temas de moda". En la caja de texto, se captura el t&eacute;rmino ingresado y se pasa al mismo tiempo que se ejecuta el evento <code>getResults</code>. Por otro lado, haciendo click en el bot&oacute;n para cargar los "Temas de moda", se ejecuta el evento <code>getTrends</code>:
              </p>
              <pre class="brush: js">
$('form').submit(function(e) {
    e.preventDefault();
    var term = $('#search_term').val();
    $('#twitter').trigger('getResults', [ term ]);
});

$('#get_trends').click(function() {
    $('#twitter').trigger('getTrends');
});
</pre>
              <p>
                A&ntilde;adiendo botones con un ID apropiado, es posible remover, colapsar, expandir y refrescar todos los contenedores de resultados al mismo tiempo. Para el bot&oacute;n que remueve el contenedor, notar que se esta pasando <code>true</code> al controlador del evento como segundo argumento, indicando que no se desea una confirmaci&oacute;n del usuario para remover el contenedor.
              </p>
              <pre class="brush: js">
$.each(['refresh', 'expand', 'collapse'], function(i, ev) {
    $('#' + ev).click(function(e) { $('#twitter div.results').trigger(ev); });
});

$('#remove').click(function(e) {
    if (confirm('Remove all results?')) {
        $('#twitter div.results').trigger('remove', [ true ]);
    }
});
</pre>
            </div>
            <div title="Conclusi&oacute;n" class="section">
                <h4>
                  Conclusi&oacute;n
                </h4>
              <p>
                Los eventos personalizados ofrecen una nueva manera de pensar el c&oacute;digo: ellos ponen el &eacute;nfasis en el objetivo de un comportamiento, no en el elemento que lo activa. Si se toma el tiempo desde el principio para explicar las piezas de su aplicaci&oacute;n, as&iacute; como los comportamientos que esas piezas necesitan exhibir, los eventos personalizados proveen una manera poderosa para "hablar" con esas piezas, ya sea de una en una o en masa.
              </p>
              <p>
              	Una vez que los comportamientos se han descripto, se convierte en algo trivial ejecutarlos desde cualquier lugar, lo que permite la r&aacute;pida creaci&oacute;n y experimentaci&oacute;n de opciones de interfaz. Finalmente, los eventos personalizados tambi&eacute;n permiten mejorar la lectura del c&oacute;digo y su mantenimiento, haciendo clara la relaci&oacute;n entre un elemento y su comportamiento.
              </p>
              <p>
                Puede ver la aplicaci&oacute;n completa en los archivos <code class="filename">demos/custom-events/custom-events.html</code> y <code class="filename">demos/custom-events/js/custom-events.js</code> del material que componen este libro.
              </p>
            </div>
          </div>
        </div>    
  </div> 		

		<p>Copyright © 2011</p>

		<p title="Aviso Legal">Material licenciado por Rebecca Murphey bajo la licencia <a href="http://creativecommons.org/licenses/by-sa/3.0/us/">Creative Commons Attribution-Share Alike 3.0 United States</a>. Usted es libre de copiarlo, distribuirlo, transmitirlo y modificarlo, siempre y cuando haga referencia a <a href="http://github.com/rmurphey/jqfundamentals">este repositorio</a> y atribuya la autor&iacute;a original a Rebecca Murphey. Si altera, transforma o crea una obra derivada, deber&aacute; distribuir el resultado bajo una licencia igual, similar o compatible. Cualquiera de las condiciones mencionadas pueden no aplicarse si obtiene permisos del autor. Para cualquier reutilizaci&oacute;n o distribuci&oacute;n, deber&aacute; dejar en claro la licencia la mejor manera para hacerlo es a trav&eacute;s de un enlace hacia la licencia <a href="http://creativecommons.org/licenses/by-sa/3.0/us/">Creative Commons Attribution-Share Alike 3.0 United States</a>.</p>
		
		<p><strong>Última actualización del libro:</strong> Julio 2011 (<a href="https://github.com/dzignus/jqfundamentals/commits/master" rel="_blank">ver cambios</a>).</p>
		
	</div>

	<script>
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16816025-3']);
	_gaq.push(['_trackPageview']);
	
	(function() {
	var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
	</script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js"></script>
	<script src="js/shCore.js"></script>
	<script src="js/shBrushJScript.js"></script>
	<script>
	$(function() {
	
		var toc = $('#toc'),
		loe = $('#loe'),
		tocItems="", loeItems="";
		
		function makeLi(text, href) {
			return '<li><a href="' + href + '">' + text + '</a></li>';
		}
		
		$('div.chapter').each(function(i) {
			var chapter = $(this),
			chapterNumber = i + 1;

			tocItems+=makeLi('Cap&iacute;tulo ' + chapterNumber + ': ' + chapter.attr('title'), '#capitulo-' + chapterNumber);

			chapter.find('div.example').each(function(j) {
			var example = $(this),
			  title = example.find('p.title'),
			  exampleNumber = chapterNumber + '.' + (j+1),
			  exampleName = title.text();

			loeItems += makeLi('Ejemplo ' + exampleNumber + ': ' + exampleName, '#ejemplo-' + exampleNumber);

			example.attr('id', 'ejemplo-' + exampleNumber);
				title.html('Ejemplo ' + exampleNumber + ': ' + exampleName);
			});

			chapter.prepend('<p class="toc"><a title="Volver al principio" href="#toc">Volver al principio</a></p>');
		});

		toc.append(tocItems);
		loe.append(loeItems);

		SyntaxHighlighter.all();
		
		$('a[rel="_blank"]').click(function(e){
			e.preventDefault();
			window.open(this.href);
		});
	
	});
	</script>
	<script src="http://platform.twitter.com/widgets.js"></script>
	</body>
</html>
